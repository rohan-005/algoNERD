[
    {
  "id": 801,
  "category_id": 8,
  "question_title": "Implement Queue Using Array",
  "question_description": "Implement a queue using an array with basic queue operations: enqueue, dequeue, front (peek), and isEmpty.",
  "question_level": "Level 1",
  "question_category": "Queue",
  "question_tags": ["queue", "array", "fifo"],
  "question_theory": [
    "A queue is a linear data structure that follows the FIFO (First In First Out) principle.",
    "Elements are inserted from the rear end and removed from the front.",
    "We maintain two indices: front and rear.",
    "Initially front = 0, rear = -1 (meaning queue is empty).",
    "Queue overflow occurs when rear reaches max size - 1 and no space left.",
    "Queue underflow occurs when front > rear."
  ],
  "question_concept": [
    "To enqueue(x): increase rear and store x at arr[rear].",
    "To dequeue(): return arr[front] and increase front.",
    "To peek(): return arr[front] without removing it.",
    "Check empty: front > rear.",
    "This is a linear non-circular queue."
  ],
  "question_explanation": [
    "All queue operations take O(1) time.",
    "This implementation is simplest, but wastes unused memory once elements are dequeued.",
    "Later problems will cover circular queue optimization."
  ],
  "solution": {
    "cpp": [
      "#include <iostream>",
      "using namespace std;",
      "",
      "#define MAX 1000",
      "",
      "class Queue {",
      "    int front, rear;",
      "public:",
      "    int arr[MAX];",
      "",
      "    Queue() {",
      "        front = 0;",
      "        rear = -1;",
      "    }",
      "",
      "    bool enqueue(int x) {",
      "        if(rear >= MAX - 1) return false;",
      "        arr[++rear] = x;",
      "        return true;",
      "    }",
      "",
      "    int dequeue() {",
      "        if(front > rear) return -1; // underflow",
      "        return arr[front++];",
      "    }",
      "",
      "    int peek() {",
      "        if(front > rear) return -1;",
      "        return arr[front];",
      "    }",
      "",
      "    bool isEmpty() {",
      "        return front > rear;",
      "    }",
      "};",
      "",
      "int main() {",
      "    Queue q;",
      "    q.enqueue(10);",
      "    q.enqueue(20);",
      "    cout << q.dequeue() << endl;", 
      "    cout << q.peek() << endl;",
      "    return 0;",
      "}"
    ],
    "python": [
      "class Queue:",
      "    def __init__(self, size=1000):",
      "        self.arr = [0] * size",
      "        self.front = 0",
      "        self.rear = -1",
      "",
      "    def enqueue(self, x):",
      "        if self.rear == len(self.arr) - 1:",
      "            return False",
      "        self.rear += 1",
      "        self.arr[self.rear] = x",
      "        return True",
      "",
      "    def dequeue(self):",
      "        if self.front > self.rear:",
      "            return -1",
      "        val = self.arr[self.front]",
      "        self.front += 1",
      "        return val",
      "",
      "    def peek(self):",
      "        if self.front > self.rear:",
      "            return -1",
      "        return self.arr[self.front]",
      "",
      "    def isEmpty(self):",
      "        return self.front > self.rear"
    ],
    "java": [
      "import java.util.*;",
      "",
      "class QueueArray {",
      "    int MAX = 1000;",
      "    int front, rear;",
      "    int[] arr = new int[MAX];",
      "",
      "    QueueArray() {",
      "        front = 0;",
      "        rear = -1;",
      "    }",
      "",
      "    boolean enqueue(int x) {",
      "        if(rear >= MAX - 1) return false;",
      "        arr[++rear] = x;",
      "        return true;",
      "    }",
      "",
      "    int dequeue() {",
      "        if(front > rear) return -1;",
      "        return arr[front++];",
      "    }",
      "",
      "    int peek() {",
      "        if(front > rear) return -1;",
      "        return arr[front];",
      "    }",
      "",
      "    boolean isEmpty() {",
      "        return front > rear;",
      "    }",
      "}",
      "",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        QueueArray q = new QueueArray();",
      "        q.enqueue(10);",
      "        q.enqueue(20);",
      "        System.out.println(q.dequeue());",
      "        System.out.println(q.peek());",
      "    }",
      "}"
    ]
  },
  "solution_explanation": [
    "Queue operations are performed at opposite ends: insert at rear, delete from front.",
    "No need to shift elements on enqueue or dequeue.",
    "Simple implementation but unoptimized memory shift."
  ],
  "dummy_test_cases_explanation": [
    {
      "input": "enqueue 10, enqueue 20, dequeue, peek",
      "output": "dequeue -> 10 , peek -> 20",
      "explanation": "FIFO behavior validated."
    }
  ],
  "tests_industry_standard": [
    {
      "input": "enqueue 5, dequeue",
      "expected_output": "5",
      "explanation": "Basic enqueue-dequeue test."
    },
    {
      "input": "dequeue (empty queue)",
      "expected_output": "-1",
      "explanation": "Underflow handling."
    }
  ],
  "dry_run_explanation": [
    "Start: front = 0, rear = -1",
    "enqueue(10) -> front = 0, rear = 0",
    "enqueue(20) -> front = 0, rear = 1",
    "dequeue() returns arr[0]=10, front = 1",
    "peek() returns arr[1]=20"
  ]
},
{
  "id": 802,
  "category_id": 8,
  "question_title": "Circular Queue",
  "question_description": "Implement a Circular Queue using an array with enqueue, dequeue, peek, and isEmpty operations.",
  "question_level": "Level 2",
  "question_category": "Queue",
  "question_tags": ["queue", "circular", "fifo"],
  "question_theory": [
    "A Circular Queue connects the end of the queue back to the beginning, forming a circular structure.",
    "This prevents unused space issues in linear queue implementation.",
    "Modulo operation is used to wrap rear and front indices within array bounds.",
    "Conditions:",
    " - Queue is empty when: front == -1",
    " - Queue is full when: (rear + 1) % size == front"
  ],
  "question_concept": [
    "Initialize front = -1, rear = -1",
    "To enqueue(x):",
    " - If full -> overflow error",
    " - If empty -> set front = 0",
    " - rear = (rear + 1) % size",
    " - arr[rear] = x",
    "To dequeue():",
    " - If empty -> underflow error",
    " - If front == rear -> reset front & rear = -1",
    " - Else front = (front + 1) % size"
  ],
  "question_explanation": [
    "Circular queue efficiently utilizes array space without shifting elements.",
    "All operations complete in O(1) time."
  ],
  "solution": {
    "cpp": [
      "#include <iostream>",
      "using namespace std;",
      "",
      "#define SIZE 5",
      "",
      "class CircularQueue {",
      "    int front, rear;",
      "    int arr[SIZE];",
      "public:",
      "    CircularQueue() {",
      "        front = rear = -1;",
      "    }",
      "",
      "    bool enqueue(int x) {",
      "        if((rear + 1) % SIZE == front) return false;",
      "        if(front == -1) front = 0;",
      "        rear = (rear + 1) % SIZE;",
      "        arr[rear] = x;",
      "        return true;",
      "    }",
      "",
      "    int dequeue() {",
      "        if(front == -1) return -1;",
      "        int val = arr[front];",
      "        if(front == rear) front = rear = -1;",
      "        else front = (front + 1) % SIZE;",
      "        return val;",
      "    }",
      "",
      "    int peek() {",
      "        if(front == -1) return -1;",
      "        return arr[front];",
      "    }",
      "};",
      "",
      "int main() {",
      "    CircularQueue q;",
      "    q.enqueue(10);",
      "    q.enqueue(20);",
      "    cout << q.dequeue() << endl;",
      "    cout << q.peek() << endl;",
      "    return 0;",
      "}"
    ],
    "python": [
      "class CircularQueue:",
      "    def __init__(self, size=5):",
      "        self.size = size",
      "        self.arr = [0] * size",
      "        self.front = -1",
      "        self.rear = -1",
      "",
      "    def enqueue(self, x):",
      "        if (self.rear + 1) % self.size == self.front:",
      "            return False",
      "        if self.front == -1:",
      "            self.front = 0",
      "        self.rear = (self.rear + 1) % self.size",
      "        self.arr[self.rear] = x",
      "        return True",
      "",
      "    def dequeue(self):",
      "        if self.front == -1:",
      "            return -1",
      "        val = self.arr[self.front]",
      "        if self.front == self.rear:",
      "            self.front = self.rear = -1",
      "        else:",
      "            self.front = (self.front + 1) % self.size",
      "        return val",
      "",
      "    def peek(self):",
      "        if self.front == -1:",
      "            return -1",
      "        return self.arr[self.front]"
    ],
    "java": [
      "import java.util.*;",
      "",
      "class CircularQueue {",
      "    int size = 5;",
      "    int front = -1, rear = -1;",
      "    int[] arr = new int[size];",
      "",
      "    boolean enqueue(int x) {",
      "        if ((rear + 1) % size == front) return false;",
      "        if (front == -1) front = 0;",
      "        rear = (rear + 1) % size;",
      "        arr[rear] = x;",
      "        return true;",
      "    }",
      "",
      "    int dequeue() {",
      "        if (front == -1) return -1;",
      "        int val = arr[front];",
      "        if (front == rear) front = rear = -1;",
      "        else front = (front + 1) % size;",
      "        return val;",
      "    }",
      "",
      "    int peek() {",
      "        if (front == -1) return -1;",
      "        return arr[front];",
      "    }",
      "}",
      "",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        CircularQueue q = new CircularQueue();",
      "        q.enqueue(10);",
      "        q.enqueue(20);",
      "        System.out.println(q.dequeue());",
      "        System.out.println(q.peek());",
      "    }",
      "}"
    ]
  },
  "solution_explanation": [
    "Modulo operation prevents overflow and allows reuse of freed indexes.",
    "Queue remains efficient without shifting elements after dequeue.",
    "Correctly handles cases of full and empty queue."
  ],
  "dummy_test_cases_explanation": [
    {
      "input": "enqueue 10, enqueue 20, dequeue, peek",
      "output": "dequeue -> 10, peek -> 20",
      "explanation": "FIFO behavior with circular rotation under-the-hood."
    }
  ],
  "tests_industry_standard": [
    {
      "input": "enqueue 1, enqueue 2, enqueue 3, enqueue 4, enqueue 5",
      "expected_output": "overflow",
      "explanation": "Queue must detect full condition."
    },
    {
      "input": "enqueue 10, enqueue 20, dequeue, enqueue 30, peek",
      "expected_output": "20",
      "explanation": "Slot reuse after dequeue is validated."
    }
  ],
  "dry_run_explanation": [
    "size = 5, start: front = -1, rear = -1",
    "enqueue(10) → front = 0, rear = 0",
    "enqueue(20) → front = 0, rear = 1",
    "dequeue() → returns 10 → front = 1",
    "enqueue(30) → rear = 2",
    "peek() → arr[1] = 20"
  ]
},
{
  "id": 803,
  "category_id": 8,
  "question_title": "Queue Using Stack",
  "question_description": "Implement a queue using two stacks and provide enqueue, dequeue, peek, and isEmpty operations.",
  "question_level": "Level 2",
  "question_category": "Queue",
  "question_tags": ["queue", "stack", "two-stacks", "fifo"],
  "question_theory": [
    "A queue follows FIFO (First In First Out) behavior, while stacks follow LIFO.",
    "To build a queue using stacks, we must reverse order when accessing elements.",
    "Two common strategies:",
    "1️⃣ Enqueue costly approach → O(n)",
    "2️⃣ Dequeue costly approach → O(n)",
    "We will use the efficient lazy transfer approach:",
    " - Push new elements into stack1",
    " - When popping, only transfer elements to stack2 if it is empty",
    "This gives amortized O(1) time complexity per operation."
  ],
  "question_concept": [
    "Data is stored in stack1.",
    "Top of stack2 always holds the front of the queue.",
    "Dequeue logic:",
    " - If stack2 empty: move all elements from stack1 → stack2",
    " - Pop from stack2",
    "Peek checks top of stack2 similarly."
  ],
  "question_explanation": [
    "Most elements move between stacks only once throughout their lifetime.",
    "Hence amortized complexity remains O(1) even though worst-case is O(n)."
  ],
  "solution": {
    "cpp": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "class MyQueue {",
      "    stack<int> s1, s2;",
      "public:",
      "    void enqueue(int x) {",
      "        s1.push(x);",
      "    }",
      "",
      "    int dequeue() {",
      "        if(isEmpty()) return -1;",
      "        if(s2.empty()) {",
      "            while(!s1.empty()) {",
      "                s2.push(s1.top());",
      "                s1.pop();",
      "            }",
      "        }",
      "        int val = s2.top();",
      "        s2.pop();",
      "        return val;",
      "    }",
      "",
      "    int peek() {",
      "        if(isEmpty()) return -1;",
      "        if(s2.empty()) {",
      "            while(!s1.empty()) {",
      "                s2.push(s1.top());",
      "                s1.pop();",
      "            }",
      "        }",
      "        return s2.top();",
      "    }",
      "",
      "    bool isEmpty() {",
      "        return s1.empty() && s2.empty();",
      "    }",
      "};",
      "",
      "int main() {",
      "    MyQueue q;",
      "    q.enqueue(1);",
      "    q.enqueue(2);",
      "    cout << q.dequeue() << endl;", 
      "    cout << q.peek() << endl;", 
      "    return 0;",
      "}"
    ],
    "python": [
      "class MyQueue:",
      "    def __init__(self):",
      "        self.s1 = []",
      "        self.s2 = []",
      "",
      "    def enqueue(self, x):",
      "        self.s1.append(x)",
      "",
      "    def dequeue(self):",
      "        if not self.s2:",
      "            while self.s1:",
      "                self.s2.append(self.s1.pop())",
      "        return self.s2.pop() if self.s2 else -1",
      "",
      "    def peek(self):",
      "        if not self.s2:",
      "            while self.s1:",
      "                self.s2.append(self.s1.pop())",
      "        return self.s2[-1] if self.s2 else -1",
      "",
      "    def isEmpty(self):",
      "        return not self.s1 and not self.s2"
    ],
    "java": [
      "import java.util.*;",
      "",
      "class MyQueue {",
      "    Stack<Integer> s1 = new Stack<>();",
      "    Stack<Integer> s2 = new Stack<>();",
      "",
      "    void enqueue(int x) {",
      "        s1.push(x);",
      "    }",
      "",
      "    int dequeue() {",
      "        if(isEmpty()) return -1;",
      "        if(s2.isEmpty()) {",
      "            while(!s1.isEmpty())",
      "                s2.push(s1.pop());",
      "        }",
      "        return s2.pop();",
      "    }",
      "",
      "    int peek() {",
      "        if(isEmpty()) return -1;",
      "        if(s2.isEmpty()) {",
      "            while(!s1.isEmpty())",
      "                s2.push(s1.pop());",
      "        }",
      "        return s2.peek();",
      "    }",
      "",
      "    boolean isEmpty() {",
      "        return s1.isEmpty() && s2.isEmpty();",
      "    }",
      "}",
      "",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        MyQueue q = new MyQueue();",
      "        q.enqueue(10);",
      "        q.enqueue(20);",
      "        System.out.println(q.dequeue());",
      "        System.out.println(q.peek());",
      "    }",
      "}"
    ]
  },
  "solution_explanation": [
    "Using two stacks preserves FIFO order by reversing order when needed.",
    "Efficient lazy transfer: elements move only once → amortized O(1) time."
  ],
  "dummy_test_cases_explanation": [
    {
      "input": "enqueue 10, enqueue 20, dequeue, peek",
      "output": "dequeue -> 10, peek -> 20",
      "explanation": "FIFO is maintained using two stacks."
    }
  ],
  "tests_industry_standard": [
    {
      "input": "enqueue 1, enqueue 2, enqueue 3, dequeue, dequeue",
      "expected_output": "1 2",
      "explanation": "Maintains correct order with multiple operations."
    },
    {
      "input": "peek on empty queue",
      "expected_output": "-1",
      "explanation": "Error handling for empty state."
    }
  ],
  "dry_run_explanation": [
    "enqueue(1): s1=[1], s2=[]",
    "enqueue(2): s1=[1,2], s2=[]",
    "dequeue(): move s1→s2 => s1=[], s2=[2,1], pop => 1",
    "peek(): return 2"
  ]
},
{
  "id": 804,
  "category_id": 8,
  "question_title": "Implement Dequeue (Double-Ended Queue)",
  "question_description": "Implement a Dequeue (Double-Ended Queue) using an array, supporting insert and delete operations from both front and rear.",
  "question_level": "Level 2",
  "question_category": "Queue",
  "question_tags": ["queue", "deque", "double-ended"],
  "question_theory": [
    "A Dequeue (or Deque) supports insertion and deletion from both ends: front and rear.",
    "Efficient in scenarios requiring both queue and stack behavior.",
    "Common applications include sliding window problems, browsers, undo operations, etc.",
    "We maintain a circular structure to keep operations O(1)."
  ],
  "question_concept": [
    "Start with front = -1, rear = -1",
    "isFull → (front == 0 && rear == size - 1) OR (front == rear + 1)",
    "isEmpty → front == -1",
    "Insert at rear → typical enqueue",
    "Insert at front → decrement front circularly",
    "Delete front → remove like dequeue",
    "Delete rear → remove from end circularly"
  ],
  "question_explanation": [
    "Deque efficiently maintains both ends with modular arithmetic.",
    "No element shifting required."
  ],
  "solution": {
    "cpp": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define SIZE 5",
      "",
      "class Deque {",
      "    int arr[SIZE];",
      "    int front, rear;",
      "",
      "public:",
      "    Deque() { front = rear = -1; }",
      "",
      "    bool isFull() {",
      "        return (front == 0 && rear == SIZE - 1) || (front == rear + 1);",
      "    }",
      "",
      "    bool isEmpty() { return front == -1; }",
      "",
      "    bool insertFront(int x) {",
      "        if(isFull()) return false;",
      "        if(isEmpty()) front = rear = 0;",
      "        else if(front == 0) front = SIZE - 1;",
      "        else front--;",
      "        arr[front] = x;",
      "        return true;",
      "    }",
      "",
      "    bool insertRear(int x) {",
      "        if(isFull()) return false;",
      "        if(isEmpty()) front = rear = 0;",
      "        else rear = (rear + 1) % SIZE;",
      "        arr[rear] = x;",
      "        return true;",
      "    }",
      "",
      "    int deleteFront() {",
      "        if(isEmpty()) return -1;",
      "        int val = arr[front];",
      "        if(front == rear) front = rear = -1;",
      "        else front = (front + 1) % SIZE;",
      "        return val;",
      "    }",
      "",
      "    int deleteRear() {",
      "        if(isEmpty()) return -1;",
      "        int val = arr[rear];",
      "        if(front == rear) front = rear = -1;",
      "        else if(rear == 0) rear = SIZE - 1;",
      "        else rear--;",
      "        return val;",
      "    }",
      "",
      "    int getFront() { return isEmpty() ? -1 : arr[front]; }",
      "    int getRear() { return isEmpty() ? -1 : arr[rear]; }",
      "};",
      "",
      "int main() {",
      "    Deque dq;",
      "    dq.insertRear(10);",
      "    dq.insertFront(20);",
      "    cout << dq.deleteRear() << endl;",
      "    cout << dq.getFront() << endl;",
      "    return 0;",
      "}"
    ],
    "python": [
      "class Deque:",
      "    def __init__(self, size=5):",
      "        self.size = size",
      "        self.arr = [0] * size",
      "        self.front = -1",
      "        self.rear = -1",
      "",
      "    def isFull(self):",
      "        return (self.front == 0 and self.rear == self.size - 1) or (self.front == self.rear + 1)",
      "",
      "    def isEmpty(self):",
      "        return self.front == -1",
      "",
      "    def insertFront(self, x):",
      "        if self.isFull(): return False",
      "        if self.isEmpty(): self.front = self.rear = 0",
      "        elif self.front == 0: self.front = self.size - 1",
      "        else: self.front -= 1",
      "        self.arr[self.front] = x",
      "        return True",
      "",
      "    def insertRear(self, x):",
      "        if self.isFull(): return False",
      "        if self.isEmpty(): self.front = self.rear = 0",
      "        else: self.rear = (self.rear + 1) % self.size",
      "        self.arr[self.rear] = x",
      "        return True",
      "",
      "    def deleteFront(self):",
      "        if self.isEmpty(): return -1",
      "        val = self.arr[self.front]",
      "        if self.front == self.rear: self.front = self.rear = -1",
      "        else: self.front = (self.front + 1) % self.size",
      "        return val",
      "",
      "    def deleteRear(self):",
      "        if self.isEmpty(): return -1",
      "        val = self.arr[self.rear]",
      "        if self.front == self.rear: self.front = self.rear = -1",
      "        elif self.rear == 0: self.rear = self.size - 1",
      "        else: self.rear -= 1",
      "        return val",
      "",
      "    def getFront(self):",
      "        return -1 if self.isEmpty() else self.arr[self.front]",
      "",
      "    def getRear(self):",
      "        return -1 if self.isEmpty() else self.arr[self.rear]"
    ],
    "java": [
      "import java.util.*;",
      "",
      "class DequeArray {",
      "    int size = 5;",
      "    int[] arr = new int[size];",
      "    int front = -1, rear = -1;",
      "",
      "    boolean isFull() {",
      "        return (front == 0 && rear == size - 1) || (front == rear + 1);",
      "    }",
      "",
      "    boolean isEmpty() {",
      "        return front == -1;",
      "    }",
      "",
      "    boolean insertFront(int x) {",
      "        if (isFull()) return false;",
      "        if (isEmpty()) front = rear = 0;",
      "        else if (front == 0) front = size - 1;",
      "        else front--;",
      "        arr[front] = x;",
      "        return true;",
      "    }",
      "",
      "    boolean insertRear(int x) {",
      "        if (isFull()) return false;",
      "        if (isEmpty()) front = rear = 0;",
      "        else rear = (rear + 1) % size;",
      "        arr[rear] = x;",
      "        return true;",
      "    }",
      "",
      "    int deleteFront() {",
      "        if (isEmpty()) return -1;",
      "        int val = arr[front];",
      "        if (front == rear) front = rear = -1;",
      "        else front = (front + 1) % size;",
      "        return val;",
      "    }",
      "",
      "    int deleteRear() {",
      "        if (isEmpty()) return -1;",
      "        int val = arr[rear];",
      "        if (front == rear) front = rear = -1;",
      "        else if (rear == 0) rear = size - 1;",
      "        else rear--;",
      "        return val;",
      "    }",
      "",
      "    int getFront() { return isEmpty() ? -1 : arr[front]; }",
      "    int getRear() { return isEmpty() ? -1 : arr[rear]; }",
      "}",
      "",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        DequeArray dq = new DequeArray();",
      "        dq.insertRear(10);",
      "        dq.insertFront(20);",
      "        System.out.println(dq.deleteRear());",
      "        System.out.println(dq.getFront());",
      "    }",
      "}"
    ]
  },
  "solution_explanation": [
    "Dequeue allows insertion and deletion at both ends with O(1) performance.",
    "Efficient implementation using circular logic avoids shifting elements.",
    "This structure is helpful in many real-world FIFO/LIFO hybrid scenarios."
  ],
  "dummy_test_cases_explanation": [
    {
      "input": "insertRear 10, insertFront 20, deleteRear, getFront",
      "output": "deleteRear -> 10, getFront -> 20",
      "explanation": "Operations validate both sides working correctly."
    }
  ],
  "tests_industry_standard": [
    {
      "input": "insertFront 1, insertRear 2, deleteFront, deleteRear",
      "expected_output": "1 2",
      "explanation": "Supports both deque ends simultaneously."
    },
    {
      "input": "deleteFront on empty deque",
      "expected_output": "-1",
      "explanation": "Handles underflow safely."
    }
  ],
  "dry_run_explanation": [
    "insertRear(10) → front=rear=0",
    "insertFront(20) → front=4, arr[4]=20",
    "deleteRear → remove 10 → front=4, rear=4",
    "getFront → arr[4] = 20"
  ]
},
{
  "id": 805,
  "category_id": 8,
  "question_title": "Sliding Window Maximum",
  "question_description": "Given an array and a window size K, find the maximum element in every contiguous window of size K using a deque.",
  "question_level": "Level 3",
  "question_category": "Queue",
  "question_tags": ["queue", "deque", "monotonic-queue", "sliding-window"],
  "question_theory": [
    "A sliding window moves across an array keeping only K elements at a time.",
    "Naive solution requires scanning K elements for each window -> O(N*K) worst case.",
    "Optimized solution: Use a Monotonic Deque.",
    "Store only useful elements inside the deque, in decreasing order.",
    "Deque front always contains the index of the current window maximum.",
    "Before adding a new element, remove:",
    " - Out-of-window elements from the front",
    " - Smaller elements from the rear"
  ],
  "question_concept": [
    "Use deque to maintain indices (not values).",
    "Always preserve window bounds: i - K + 1.",
    "Each element is pushed and popped at most once -> O(N)."
  ],
  "question_explanation": [
    "The deque eliminates unnecessary comparisons by removing smaller elements from the back.",
    "This ensures each window's max is fetched in O(1).",
    "Entire algorithm runs in linear time."
  ],
  "solution": {
    "cpp": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "int main() {",
      "    int n, k;",
      "    cin >> n >> k;",
      "    vector<int> arr(n);",
      "    for(int i = 0; i < n; i++) cin >> arr[i];",
      "",
      "    deque<int> dq;",
      "    vector<int> result;",
      "",
      "    for(int i = 0; i < n; i++) {",
      "        if(!dq.empty() && dq.front() <= i - k)",
      "            dq.pop_front();",
      "",
      "        while(!dq.empty() && arr[dq.back()] <= arr[i])",
      "            dq.pop_back();",
      "",
      "        dq.push_back(i);",
      "",
      "        if(i >= k - 1)",
      "            result.push_back(arr[dq.front()]);",
      "    }",
      "",
      "    for(int x : result) cout << x << \" \";",
      "    return 0;",
      "}"
    ],
    "python": [
      "from collections import deque",
      "",
      "n, k = map(int, input().split())",
      "arr = list(map(int, input().split()))",
      "",
      "dq = deque()",
      "result = []",
      "",
      "for i in range(n):",
      "    if dq and dq[0] <= i - k:",
      "        dq.popleft()",
      "",
      "    while dq and arr[dq[-1]] <= arr[i]:",
      "        dq.pop()",
      "",
      "    dq.append(i)",
      "",
      "    if i >= k - 1:",
      "        result.append(arr[dq[0]])",
      "",
      "print(*result)"
    ],
    "java": [
      "import java.util.*;",
      "",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        Scanner sc = new Scanner(System.in);",
      "        int n = sc.nextInt();",
      "        int k = sc.nextInt();",
      "        int[] arr = new int[n];",
      "        for(int i = 0; i < n; i++) arr[i] = sc.nextInt();",
      "",
      "        Deque<Integer> dq = new LinkedList<>();",
      "        ArrayList<Integer> result = new ArrayList<>();",
      "",
      "        for(int i = 0; i < n; i++) {",
      "            if(!dq.isEmpty() && dq.peekFirst() <= i - k)",
      "                dq.pollFirst();",
      "",
      "            while(!dq.isEmpty() && arr[dq.peekLast()] <= arr[i])",
      "                dq.pollLast();",
      "",
      "            dq.offerLast(i);",
      "",
      "            if(i >= k - 1) result.add(arr[dq.peekFirst()]);",
      "        }",
      "",
      "        for(int x : result)",
      "            System.out.print(x + \" \");",
      "    }",
      "}"
    ]
  },
  "solution_explanation": [
    "Deque maintains elements indices in descending order of values.",
    "Each element processed only once -> O(N).",
    "Fastest industry-standard solution for sliding window maximum."
  ],
  "dummy_test_cases_explanation": [
    {
      "input": "n=8, k=3\narr = 1 3 -1 -3 5 3 6 7",
      "output": "3 3 5 5 6 7",
      "explanation": "Correctly tracks each window's peak."
    }
  ],
  "tests_industry_standard": [
    {
      "input": "n=5, k=2\narr = 2 1 5 2 6",
      "expected_output": "2 5 5 6",
      "explanation": "Checks variations in high-low-high window patterns."
    },
    {
      "input": "n=3, k=3\narr = 9 3 1",
      "expected_output": "9",
      "explanation": "Single window scenario."
    }
  ],
  "dry_run_explanation": [
    "arr = [1,3,-1,-3,5,3,6,7], k = 3",
    "Window 1: [1,3,-1] -> 3",
    "Window 2: [3,-1,-3] -> 3",
    "Window 3: [-1,-3,5] -> 5",
    "Window 4: [-3,5,3] -> 5",
    "Window 5: [5,3,6] -> 6",
    "Window 6: [3,6,7] -> 7"
  ]
}






]