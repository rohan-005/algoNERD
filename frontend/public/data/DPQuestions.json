[
  {
    "id": 1101,
    "category_id": 11,
    "question_title": "0/1 Knapsack Problem",
    "question_description": "Given weights and values of N items and a knapsack capacity W, find the maximum total value that can be put into the knapsack. Each item can be taken at most once (0/1).",
    "question_level": "Level 3",
    "question_category": "Dynamic Programming",
    "question_tags": ["dp", "knapsack", "optimization"],
    "question_theory": [
      "The 0/1 Knapsack problem is a classic optimization problem solved efficiently using Dynamic Programming.",
      "Each item can either be included or excluded, leading to an exponential number of subsets if solved by brute force.",
      "The DP approach uses the idea of overlapping subproblems and optimal substructure.",
      "We define a state that represents the best answer for a prefix of items and a limited capacity."
    ],
    "question_concept": [
      "Let weights[i] and values[i] be the weight and value of the i-th item (0-indexed).",
      "Define a function f(i, w) that returns the maximum value using items from index i to N-1 with remaining capacity w.",
      "Recurrence: f(i, w) = max( f(i+1, w), values[i] + f(i+1, w - weights[i]) ) if weights[i] <= w, otherwise skip the item.",
      "Use Memoization (Top-Down) or Tabulation (Bottom-Up) to store previously computed results.",
      "Bottom-Up DP uses a 2D table dp[i][w] meaning max value using first i items and capacity w."
    ],
    "question_explanation": [
      "At each item we have two choices: take it or skip it.",
      "If we take it, we add its value and decrease the remaining capacity.",
      "If we skip it, we just move to the next item with same capacity.",
      "The DP ensures we do not recompute the same (index, capacity) states repeatedly.",
      "The final answer for Bottom-Up version is dp[N][W], and for Top-Down it is f(0, W)."
    ],
    "solution": {
      "cpp": [
        "#include <bits/stdc++.h>",
        "using namespace std;",
        "",
        "// ----- Top-Down (Memoization) -----",
        "int n, W;",
        "vector<int> wt, val;",
        "vector<vector<int>> memo;",
        "",
        "int knapTD(int i, int w) {",
        "    if (i == n || w == 0) return 0;",
        "    if (memo[i][w] != -1) return memo[i][w];",
        "",
        "    int ans = knapTD(i + 1, w); // skip item",
        "    if (wt[i] <= w) {",
        "        ans = max(ans, val[i] + knapTD(i + 1, w - wt[i]));",
        "    }",
        "    return memo[i][w] = ans;",
        "}",
        "",
        "// ----- Bottom-Up (Tabulation) -----",
        "int main() {",
        "    cin >> n >> W;",
        "    wt.resize(n);",
        "    val.resize(n);",
        "    for (int i = 0; i < n; i++) cin >> wt[i];",
        "    for (int i = 0; i < n; i++) cin >> val[i];",
        "",
        "    // Top-Down call preparation",
        "    memo.assign(n, vector<int>(W + 1, -1));",
        "    int ansTD = knapTD(0, W);",
        "",
        "    // Bottom-Up table",
        "    vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));",
        "    for (int i = n - 1; i >= 0; i--) {",
        "        for (int w = 0; w <= W; w++) {",
        "            int notTake = dp[i + 1][w];",
        "            int take = 0;",
        "            if (wt[i] <= w) take = val[i] + dp[i + 1][w - wt[i]];",
        "            dp[i][w] = max(take, notTake);",
        "        }",
        "    }",
        "",
        "    int ansBU = dp[0][W];",
        "    // Both ansTD and ansBU should be equal; we print Bottom-Up answer",
        "    cout << ansBU;",
        "    return 0;",
        "}"
      ],
      "python": [
        "# ----- Input -----",
        "n, W = map(int, input().split())",
        "wt = list(map(int, input().split()))",
        "val = list(map(int, input().split()))",
        "",
        "# ----- Top-Down (Memoization) -----",
        "from functools import lru_cache",
        "",
        "@lru_cache(maxsize=None)",
        "def knap_td(i, w):",
        "    if i == n or w == 0:",
        "        return 0",
        "    ans = knap_td(i + 1, w)  # skip",
        "    if wt[i] <= w:",
        "        ans = max(ans, val[i] + knap_td(i + 1, w - wt[i]))",
        "    return ans",
        "",
        "ans_td = knap_td(0, W)",
        "",
        "# ----- Bottom-Up (Tabulation) -----",
        "dp = [[0] * (W + 1) for _ in range(n + 1)]",
        "for i in range(n - 1, -1, -1):",
        "    for w in range(W + 1):",
        "        not_take = dp[i + 1][w]",
        "        take = 0",
        "        if wt[i] <= w:",
        "            take = val[i] + dp[i + 1][w - wt[i]]",
        "        dp[i][w] = max(take, not_take)",
        "",
        "ans_bu = dp[0][W]",
        "print(ans_bu)"
      ],
      "java": [
        "import java.util.*;",
        "",
        "public class Main {",
        "    static int n, W;",
        "    static int[] wt, val;",
        "    static int[][] memo;",
        "",
        "    // ----- Top-Down (Memoization) -----",
        "    static int knapTD(int i, int w) {",
        "        if (i == n || w == 0) return 0;",
        "        if (memo[i][w] != -1) return memo[i][w];",
        "        int ans = knapTD(i + 1, w);",
        "        if (wt[i] <= w)",
        "            ans = Math.max(ans, val[i] + knapTD(i + 1, w - wt[i]));",
        "        return memo[i][w] = ans;",
        "    }",
        "",
        "    public static void main(String[] args) {",
        "        Scanner sc = new Scanner(System.in);",
        "        n = sc.nextInt();",
        "        W = sc.nextInt();",
        "        wt = new int[n];",
        "        val = new int[n];",
        "        for (int i = 0; i < n; i++) wt[i] = sc.nextInt();",
        "        for (int i = 0; i < n; i++) val[i] = sc.nextInt();",
        "",
        "        memo = new int[n][W + 1];",
        "        for (int i = 0; i < n; i++)",
        "            Arrays.fill(memo[i], -1);",
        "",
        "        int ansTD = knapTD(0, W);",
        "",
        "        // ----- Bottom-Up (Tabulation) -----",
        "        int[][] dp = new int[n + 1][W + 1];",
        "        for (int i = n - 1; i >= 0; i--) {",
        "            for (int w = 0; w <= W; w++) {",
        "                int notTake = dp[i + 1][w];",
        "                int take = 0;",
        "                if (wt[i] <= w) take = val[i] + dp[i + 1][w - wt[i]];",
        "                dp[i][w] = Math.max(take, notTake);",
        "            }",
        "        }",
        "        int ansBU = dp[0][W];",
        "        System.out.print(ansBU);",
        "    }",
        "}"
      ]
    },
    "solution_explanation": [
      "Both Top-Down and Bottom-Up are based on the same recurrence relation.",
      "Top-Down recursion with memoization is often easier to derive from the brute-force solution.",
      "Bottom-Up tabulation iteratively fills the DP table from smaller subproblems to bigger ones.",
      "Time complexity is O(N * W) and space complexity is also O(N * W) in the 2D DP approach.",
      "Space optimization is possible using 1D DP, but the core idea remains the same."
    ],
    "dummy_test_cases_explanation": [
      {
        "input": "4 7\n1 3 4 5\n1 4 5 7",
        "output": "9",
        "explanation": "We can take items with weight 3 and 4 (values 4 + 5 = 9) within capacity 7. That is optimal."
      }
    ],
    "tests_industry_standard": [
      {
        "input": "3 50\n10 20 30\n60 100 120",
        "expected_output": "220",
        "explanation": "Choose items with weight 20 and 30 (100 + 120) under capacity 50."
      },
      {
        "input": "1 5\n10\n100",
        "expected_output": "0",
        "explanation": "Item weight exceeds capacity, so no item can be taken."
      }
    ],
    "dry_run_explanation": [
      "Consider n = 4, W = 7, weights = [1,3,4,5], values = [1,4,5,7].",
      "At i=3, we can take weight 5 if capacity >=5, else skip.",
      "At i=2, we choose between taking (value 5 + best of remaining capacity 3) or skipping.",
      "The optimal combination is taking items of weight 3 and 4 with total value 9.",
      "DP table dp[i][w] stores these computed optimal sub-results leading to final answer at dp[0][7]."
    ]
  },
  {
    "id": 1102,
    "category_id": 11,
    "question_title": "Longest Increasing Subsequence",
    "question_description": "Given an array of integers, find the length of the Longest Increasing Subsequence (LIS). A subsequence is derived by deleting zero or more elements without changing the order of remaining elements.",
    "question_level": "Level 3",
    "question_category": "Dynamic Programming",
    "question_tags": ["dp", "lis", "subsequence"],
    "question_theory": [
      "The LIS problem asks for the longest subsequence where elements are strictly increasing.",
      "Brute force trying all subsequences is exponential in time.",
      "A classical DP solution uses O(n^2) time with a 1D dp array.",
      "An optimized solution uses patience sorting technique and binary search in O(n log n) time."
    ],
    "question_concept": [
      "O(n^2) DP: dp[i] = length of LIS ending at index i.",
      "Transition: dp[i] = 1 + max(dp[j]) for all j < i with arr[j] < arr[i]; if no such j, dp[i] = 1.",
      "Answer is max over all dp[i].",
      "Optimized O(n log n): Maintain a 'tails' array where tails[len] is the minimum possible tail value of an LIS of length len + 1.",
      "For each element, we find its position in tails using binary search and update accordingly."
    ],
    "question_explanation": [
      "The O(n^2) DP builds LIS lengths incrementally by checking all previous elements.",
      "The optimized method does not store actual LIS but the structure needed to get its length.",
      "Both methods rely on the increasing nature of subsequences and reusing results of previous computations."
    ],
    "solution": {
      "cpp": [
        "#include <bits/stdc++.h>",
        "using namespace std;",
        "",
        "int main() {",
        "    int n;",
        "    cin >> n;",
        "    vector<int> a(n);",
        "    for (int i = 0; i < n; i++) cin >> a[i];",
        "",
        "    // ----- O(n^2) DP -----",
        "    vector<int> dp(n, 1);",
        "    int ansN2 = 0;",
        "    for (int i = 0; i < n; i++) {",
        "        for (int j = 0; j < i; j++) {",
        "            if (a[j] < a[i])",
        "                dp[i] = max(dp[i], dp[j] + 1);",
        "        }",
        "        ansN2 = max(ansN2, dp[i]);",
        "    }",
        "",
        "    // ----- O(n log n) using tails array -----",
        "    vector<int> tails;",
        "    for (int x : a) {",
        "        auto it = lower_bound(tails.begin(), tails.end(), x);",
        "        if (it == tails.end()) tails.push_back(x);",
        "        else *it = x;",
        "    }",
        "    int ansLogN = (int)tails.size();",
        "",
        "    // We print O(n^2) answer (same as ansLogN)",
        "    cout << ansN2;",
        "    return 0;",
        "}"
      ],
      "python": [
        "n = int(input())",
        "a = list(map(int, input().split()))",
        "",
        "# ----- O(n^2) DP -----",
        "dp = [1] * n",
        "ans_n2 = 0",
        "for i in range(n):",
        "    for j in range(i):",
        "        if a[j] < a[i]:",
        "            dp[i] = max(dp[i], dp[j] + 1)",
        "    ans_n2 = max(ans_n2, dp[i])",
        "",
        "# ----- O(n log n) using tails array -----",
        "import bisect",
        "tails = []",
        "for x in a:",
        "    idx = bisect.bisect_left(tails, x)",
        "    if idx == len(tails):",
        "        tails.append(x)",
        "    else:",
        "        tails[idx] = x",
        "ans_log = len(tails)",
        "",
        "print(ans_n2)"
      ],
      "java": [
        "import java.util.*;",
        "",
        "public class Main {",
        "    public static void main(String[] args) {",
        "        Scanner sc = new Scanner(System.in);",
        "        int n = sc.nextInt();",
        "        int[] a = new int[n];",
        "        for (int i = 0; i < n; i++) a[i] = sc.nextInt();",
        "",
        "        // ----- O(n^2) DP -----",
        "        int[] dp = new int[n];",
        "        Arrays.fill(dp, 1);",
        "        int ansN2 = 0;",
        "        for (int i = 0; i < n; i++) {",
        "            for (int j = 0; j < i; j++) {",
        "                if (a[j] < a[i])",
        "                    dp[i] = Math.max(dp[i], dp[j] + 1);",
        "            }",
        "            ansN2 = Math.max(ansN2, dp[i]);",
        "        }",
        "",
        "        // ----- O(n log n) with tails -----",
        "        ArrayList<Integer> tails = new ArrayList<>();",
        "        for (int x : a) {",
        "            int idx = Collections.binarySearch(tails, x);",
        "            if (idx < 0) idx = -idx - 1;",
        "            if (idx == tails.size()) tails.add(x);",
        "            else tails.set(idx, x);",
        "        }",
        "        int ansLog = tails.size();",
        "",
        "        System.out.print(ansN2);",
        "    }",
        "}"
      ]
    },
    "solution_explanation": [
      "The O(n^2) solution checks all previous elements to extend an increasing subsequence ending at each index.",
      "The dp[i] value means the LIS length ending at i, which depends on values at indices < i.",
      "The O(n log n) method maintains a tails array where each position stores the minimum possible tail for an LIS of a certain length.",
      "Binary search is used to find where to place the current element in tails.",
      "Both approaches give the same length; we typically print the O(n^2) dp answer for simplicity."
    ],
    "dummy_test_cases_explanation": [
      {
        "input": "6\n10 9 2 5 3 7",
        "output": "3",
        "explanation": "One LIS is [2,5,7] with length 3. Another is [2,3,7]."
      }
    ],
    "tests_industry_standard": [
      {
        "input": "8\n0 1 0 3 2 3 4 5",
        "expected_output": "6",
        "explanation": "LIS with length 6: [0,1,2,3,4,5]."
      },
      {
        "input": "4\n4 3 2 1",
        "expected_output": "1",
        "explanation": "All elements are decreasing, so LIS length is 1."
      }
    ],
    "dry_run_explanation": [
      "For array [10, 9, 2, 5, 3, 7]:",
      "dp initially [1,1,1,1,1,1].",
      "At index 2 (value 2), dp[2] = 1.",
      "At index 3 (value 5), it can follow 2, so dp[3] = dp[2] + 1 = 2.",
      "At index 4 (value 3), it can follow 2, so dp[4] = 2.",
      "At index 5 (value 7), it can follow 2,5 or 2,3; best is length 3.",
      "Answer is max(dp) = 3."
    ]
  },
  {
    "id": 1103,
    "category_id": 11,
    "question_title": "Coin Change Problem (Minimum Coins)",
    "question_description": "Given an amount and a list of coin denominations, find the minimum number of coins needed to make that amount. If it is not possible, return -1.",
    "question_level": "Level 3",
    "question_category": "Dynamic Programming",
    "question_tags": ["dp", "coin-change", "optimization"],
    "question_theory": [
      "Coin Change (minimum coins) is a classic unbounded knapsack-type DP problem.",
      "Greedy does not always work unless coin system has special properties.",
      "DP builds solution for all amounts from 0 to target by reusing smaller sub-results.",
      "Coins can be used infinitely many times."
    ],
    "question_concept": [
      "Let coins[] be the denominations and amount be A.",
      "Top-Down state: f(remaining) = minimum coins to form that remaining amount.",
      "Recurrence: f(rem) = 1 + min(f(rem - coin) for each coin) if rem >= coin.",
      "Base: f(0) = 0; if rem < 0 then invalid (infinity).",
      "Bottom-Up: dp[x] = minimum coins to get sum x; dp[0] = 0, others initialized to large INF.",
      "Answer is dp[A]; if dp[A] remains INF, return -1."
    ],
    "question_explanation": [
      "At each state we try using every coin and choose the minimum number of coins among all valid options.",
      "This is an unbounded problem since you can reuse the same coin multiple times.",
      "DP avoids recomputing the same amount again and again, reducing complexity drastically."
    ],
    "solution": {
      "cpp": [
        "#include <bits/stdc++.h>",
        "using namespace std;",
        "",
        "int n, amount;",
        "vector<int> coins;",
        "vector<int> memo;",
        "const int INF = 1e9;",
        "",
        "// ----- Top-Down (Memoization) -----",
        "int solveTD(int rem) {",
        "    if (rem == 0) return 0;",
        "    if (rem < 0) return INF;",
        "    if (memo[rem] != -1) return memo[rem];",
        "    int ans = INF;",
        "    for (int c : coins) {",
        "        ans = min(ans, 1 + solveTD(rem - c));",
        "    }",
        "    return memo[rem] = ans;",
        "}",
        "",
        "int main() {",
        "    cin >> n >> amount;",
        "    coins.resize(n);",
        "    for (int i = 0; i < n; i++) cin >> coins[i];",
        "",
        "    memo.assign(amount + 1, -1);",
        "    int ansTD = solveTD(amount);",
        "",
        "    // ----- Bottom-Up (Tabulation) -----",
        "    vector<int> dp(amount + 1, INF);",
        "    dp[0] = 0;",
        "    for (int x = 1; x <= amount; x++) {",
        "        for (int c : coins) {",
        "            if (x - c >= 0)",
        "                dp[x] = min(dp[x], dp[x - c] + 1);",
        "        }",
        "    }",
        "    int ansBU = dp[amount];",
        "    int finalAns = ansBU >= INF ? -1 : ansBU;",
        "    cout << finalAns;",
        "    return 0;",
        "}"
      ],
      "python": [
        "n, amount = map(int, input().split())",
        "coins = list(map(int, input().split()))",
        "",
        "INF = 10**9",
        "",
        "# ----- Top-Down (Memoization) -----",
        "from functools import lru_cache",
        "",
        "@lru_cache(maxsize=None)",
        "def solve_td(rem):",
        "    if rem == 0:",
        "        return 0",
        "    if rem < 0:",
        "        return INF",
        "    ans = INF",
        "    for c in coins:",
        "        ans = min(ans, 1 + solve_td(rem - c))",
        "    return ans",
        "",
        "ans_td = solve_td(amount)",
        "",
        "# ----- Bottom-Up (Tabulation) -----",
        "dp = [INF] * (amount + 1)",
        "dp[0] = 0",
        "for x in range(1, amount + 1):",
        "    for c in coins:",
        "        if x - c >= 0:",
        "            dp[x] = min(dp[x], dp[x - c] + 1)",
        "",
        "ans_bu = dp[amount]",
        "print(-1 if ans_bu >= INF else ans_bu)"
      ],
      "java": [
        "import java.util.*;",
        "",
        "public class Main {",
        "    static final int INF = (int)1e9;",
        "    static int n, amount;",
        "    static int[] coins;",
        "",
        "    // Top-Down",
        "    static int[] memo;",
        "    static int solveTD(int rem) {",
        "        if (rem == 0) return 0;",
        "        if (rem < 0) return INF;",
        "        if (memo[rem] != -1) return memo[rem];",
        "        int ans = INF;",
        "        for (int c : coins) {",
        "            ans = Math.min(ans, 1 + solveTD(rem - c));",
        "        }",
        "        return memo[rem] = ans;",
        "    }",
        "",
        "    public static void main(String[] args) {",
        "        Scanner sc = new Scanner(System.in);",
        "        n = sc.nextInt();",
        "        amount = sc.nextInt();",
        "        coins = new int[n];",
        "        for (int i = 0; i < n; i++) coins[i] = sc.nextInt();",
        "",
        "        memo = new int[amount + 1];",
        "        Arrays.fill(memo, -1);",
        "        int ansTD = solveTD(amount);",
        "",
        "        // Bottom-Up",
        "        int[] dp = new int[amount + 1];",
        "        Arrays.fill(dp, INF);",
        "        dp[0] = 0;",
        "        for (int x = 1; x <= amount; x++) {",
        "            for (int c : coins) {",
        "                if (x - c >= 0) {",
        "                    dp[x] = Math.min(dp[x], dp[x - c] + 1);",
        "                }",
        "            }",
        "        }",
        "        int ansBU = dp[amount];",
        "        int finalAns = ansBU >= INF ? -1 : ansBU;",
        "        System.out.print(finalAns);",
        "    }",
        "}"
      ]
    },
    "solution_explanation": [
      "The DP state is the remaining amount we need to form.",
      "For each state we try to subtract every coin and take the minimal number of coins.",
      "Top-Down recursion with memoization naturally follows the definition of f(rem).",
      "Bottom-Up iteratively builds answers for all amounts from 1 to A.",
      "If the result is still INF (unreachable), we return -1 indicating no solution."
    ],
    "dummy_test_cases_explanation": [
      {
        "input": "3 11\n1 2 5",
        "output": "3",
        "explanation": "11 = 5 + 5 + 1, so minimum 3 coins are required."
      }
    ],
    "tests_industry_standard": [
      {
        "input": "1 3\n2",
        "expected_output": "-1",
        "explanation": "We cannot make 3 using only coin 2, so answer is -1."
      },
      {
        "input": "2 0\n1 3",
        "expected_output": "0",
        "explanation": "Amount is 0, so we need 0 coins."
      }
    ],
    "dry_run_explanation": [
      "For coins [1,2,5] and amount 11:",
      "dp[0] = 0.",
      "dp[1] = 1 (1).",
      "dp[2] = 1 (2).",
      "dp[3] = 2 (1+2).",
      "dp[5] = 1 (5).",
      "Eventually dp[11] = min(dp[10] + 1 using coin 1, dp[9] + 1 using 2, dp[6] + 1 using 5).",
      "The best is 5 + 5 + 1 with total 3 coins."
    ]
  },
  {
    "id": 1104,
    "category_id": 11,
    "question_title": "Edit Distance",
    "question_description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 into word2. Allowed operations: insert a character, delete a character, replace a character.",
    "question_level": "Level 3",
    "question_category": "Dynamic Programming",
    "question_tags": ["dp", "edit-distance", "string"],
    "question_theory": [
      "Edit Distance (Levenshtein distance) measures how dissimilar two strings are.",
      "The problem has an optimal substructure where the solution for prefixes depends on solutions for smaller prefixes.",
      "Allowed operations lead to three main transitions: insert, delete, and replace.",
      "Dynamic Programming avoids recomputing distances for the same pair of prefixes."
    ],
    "question_concept": [
      "Let word1 length be m and word2 length be n.",
      "Define f(i, j) = minimum edits to convert prefix word1[0..i-1] to word2[0..j-1].",
      "Base cases: f(0, j) = j (all inserts), f(i, 0) = i (all deletes).",
      "If characters match (word1[i-1] == word2[j-1]), then f(i, j) = f(i-1, j-1).",
      "Else f(i, j) = 1 + min( f(i-1, j) delete, f(i, j-1) insert, f(i-1, j-1) replace )."
    ],
    "question_explanation": [
      "Top-Down recursion follows the natural thought process of matching characters from the end.",
      "Bottom-Up DP fills a 2D table for all possible prefix pairs.",
      "The final answer is f(m, n), the cost to convert entire word1 to word2.",
      "Both approaches rely on the same recurrence relation."
    ],
    "solution": {
      "cpp": [
        "#include <bits/stdc++.h>",
        "using namespace std;",
        "",
        "string s, t;",
        "vector<vector<int>> memo;",
        "",
        "int solveTD(int i, int j) {",
        "    if (i == 0) return j;",
        "    if (j == 0) return i;",
        "    if (memo[i][j] != -1) return memo[i][j];",
        "    if (s[i - 1] == t[j - 1])",
        "        return memo[i][j] = solveTD(i - 1, j - 1);",
        "    int del = solveTD(i - 1, j);      // delete from s",
        "    int ins = solveTD(i, j - 1);      // insert into s",
        "    int rep = solveTD(i - 1, j - 1);  // replace",
        "    return memo[i][j] = 1 + min({del, ins, rep});",
        "}",
        "",
        "int main() {",
        "    cin >> s >> t;",
        "    int m = s.size(), n = t.size();",
        "",
        "    // Top-Down",
        "    memo.assign(m + 1, vector<int>(n + 1, -1));",
        "    int ansTD = solveTD(m, n);",
        "",
        "    // Bottom-Up",
        "    vector<vector<int>> dp(m + 1, vector<int>(n + 1));",
        "    for (int i = 0; i <= m; i++) dp[i][0] = i;",
        "    for (int j = 0; j <= n; j++) dp[0][j] = j;",
        "    for (int i = 1; i <= m; i++) {",
        "        for (int j = 1; j <= n; j++) {",
        "            if (s[i - 1] == t[j - 1])",
        "                dp[i][j] = dp[i - 1][j - 1];",
        "            else {",
        "                int del = dp[i - 1][j];",
        "                int ins = dp[i][j - 1];",
        "                int rep = dp[i - 1][j - 1];",
        "                dp[i][j] = 1 + min({del, ins, rep});",
        "            }",
        "        }",
        "    }",
        "    int ansBU = dp[m][n];",
        "    cout << ansBU;",
        "    return 0;",
        "}"
      ],
      "python": [
        "s = input().strip()",
        "t = input().strip()",
        "m, n = len(s), len(t)",
        "",
        "from functools import lru_cache",
        "",
        "# ----- Top-Down (Memoization) -----",
        "@lru_cache(maxsize=None)",
        "def solve_td(i, j):",
        "    if i == 0:",
        "        return j",
        "    if j == 0:",
        "        return i",
        "    if s[i-1] == t[j-1]:",
        "        return solve_td(i-1, j-1)",
        "    delete = solve_td(i-1, j)",
        "    insert = solve_td(i, j-1)",
        "    replace = solve_td(i-1, j-1)",
        "    return 1 + min(delete, insert, replace)",
        "",
        "ans_td = solve_td(m, n)",
        "",
        "# ----- Bottom-Up (Tabulation) -----",
        "dp = [[0]*(n+1) for _ in range(m+1)]",
        "for i in range(m+1):",
        "    dp[i][0] = i",
        "for j in range(n+1):",
        "    dp[0][j] = j",
        "",
        "for i in range(1, m+1):",
        "    for j in range(1, n+1):",
        "        if s[i-1] == t[j-1]:",
        "            dp[i][j] = dp[i-1][j-1]",
        "        else:",
        "            delete = dp[i-1][j]",
        "            insert = dp[i][j-1]",
        "            replace = dp[i-1][j-1]",
        "            dp[i][j] = 1 + min(delete, insert, replace)",
        "",
        "ans_bu = dp[m][n]",
        "print(ans_bu)"
      ],
      "java": [
        "import java.util.*;",
        "",
        "public class Main {",
        "    static String s, t;",
        "    static int[][] memo;",
        "",
        "    static int solveTD(int i, int j) {",
        "        if (i == 0) return j;",
        "        if (j == 0) return i;",
        "        if (memo[i][j] != -1) return memo[i][j];",
        "        if (s.charAt(i - 1) == t.charAt(j - 1))",
        "            return memo[i][j] = solveTD(i - 1, j - 1);",
        "        int del = solveTD(i - 1, j);",
        "        int ins = solveTD(i, j - 1);",
        "        int rep = solveTD(i - 1, j - 1);",
        "        return memo[i][j] = 1 + Math.min(del, Math.min(ins, rep));",
        "    }",
        "",
        "    public static void main(String[] args) {",
        "        Scanner sc = new Scanner(System.in);",
        "        s = sc.next();",
        "        t = sc.next();",
        "        int m = s.length(), n = t.length();",
        "",
        "        memo = new int[m + 1][n + 1];",
        "        for (int i = 0; i <= m; i++)",
        "            Arrays.fill(memo[i], -1);",
        "        int ansTD = solveTD(m, n);",
        "",
        "        int[][] dp = new int[m + 1][n + 1];",
        "        for (int i = 0; i <= m; i++) dp[i][0] = i;",
        "        for (int j = 0; j <= n; j++) dp[0][j] = j;",
        "",
        "        for (int i = 1; i <= m; i++) {",
        "            for (int j = 1; j <= n; j++) {",
        "                if (s.charAt(i - 1) == t.charAt(j - 1))",
        "                    dp[i][j] = dp[i - 1][j - 1];",
        "                else {",
        "                    int del = dp[i - 1][j];",
        "                    int ins = dp[i][j - 1];",
        "                    int rep = dp[i - 1][j - 1];",
        "                    dp[i][j] = 1 + Math.min(del, Math.min(ins, rep));",
        "                }",
        "            }",
        "        }",
        "        int ansBU = dp[m][n];",
        "        System.out.print(ansBU);",
        "    }",
        "}"
      ]
    },
    "solution_explanation": [
      "The DP builds the minimal edit operations needed as we increase the prefix lengths.",
      "If the last characters match, no new cost is added; otherwise we try insert, delete, or replace.",
      "Top-Down solution uses recursion and memo to store f(i, j).",
      "Bottom-Up solution iteratively fills the dp table row by row.",
      "Both yield the same complexity: O(m * n) time and space."
    ],
    "dummy_test_cases_explanation": [
      {
        "input": "horse\nros",
        "output": "3",
        "explanation": "horse -> rorse (replace h->r), rorse -> rose (remove r), rose -> ros (remove e). Total 3 edits."
      }
    ],
    "tests_industry_standard": [
      {
        "input": "intention\nexecution",
        "expected_output": "5",
        "explanation": "A standard LeetCode example with optimal edit distance 5."
      },
      {
        "input": "abc\nabc",
        "expected_output": "0",
        "explanation": "Strings already equal, no edits needed."
      }
    ],
    "dry_run_explanation": [
      "For s = horse, t = ros:",
      "Base row: converting empty string to prefixes of 'ros' costs 0,1,2,3.",
      "Base column: converting prefixes of 'horse' to empty costs 0,1,2,3,4,5.",
      "Filling dp cell by cell, we consider match or minimal of insert/delete/replace transitions.",
      "The final cell dp[5][3] gives answer 3."
    ]
  },
  {
    "id": 1105,
    "category_id": 11,
    "question_title": "Climbing Stairs",
    "question_description": "You are climbing a staircase with n steps. Each time you can climb 1 or 2 steps. Find in how many distinct ways you can climb to the top.",
    "question_level": "Level 2",
    "question_category": "Dynamic Programming",
    "question_tags": ["dp", "fibonacci", "combinatorics"],
    "question_theory": [
      "Climbing Stairs is a classic DP problem equivalent to computing Fibonacci numbers.",
      "The ways to reach step i depend on ways to reach i-1 and i-2.",
      "The recurrence is ways[i] = ways[i-1] + ways[i-2].",
      "DP or simple iteration can compute the answer in linear time."
    ],
    "question_concept": [
      "Let f(n) be the number of ways to reach the nth step.",
      "Base cases: f(0) = 1 (stay at ground), f(1) = 1.",
      "Recurrence: for n >= 2, f(n) = f(n-1) + f(n-2).",
      "Top-Down: use recursion with memoization.",
      "Bottom-Up: iteratively compute from 0..n using a small dp array or just two variables."
    ],
    "question_explanation": [
      "At each step you either came from one step below (1 jump) or two steps below (2 jumps).",
      "So number of ways to reach step i is sum of ways to reach previous two steps.",
      "This structure is identical to Fibonacci sequence shifted in index.",
      "We can compute this efficiently using DP without recursion overhead."
    ],
    "solution": {
      "cpp": [
        "#include <bits/stdc++.h>",
        "using namespace std;",
        "",
        "vector<long long> memo;",
        "",
        "// Top-Down",
        "long long waysTD(int n) {",
        "    if (n == 0) return 1;",
        "    if (n == 1) return 1;",
        "    if (memo[n] != -1) return memo[n];",
        "    return memo[n] = waysTD(n - 1) + waysTD(n - 2);",
        "}",
        "",
        "int main() {",
        "    int n;",
        "    cin >> n;",
        "",
        "    memo.assign(n + 1, -1);",
        "    long long ansTD = waysTD(n);",
        "",
        "    // Bottom-Up with O(1) space",
        "    if (n == 0) {",
        "        cout << 1;",
        "        return 0;",
        "    }",
        "    long long prev2 = 1; // f(0)",
        "    long long prev1 = 1; // f(1)",
        "    long long cur = prev1;",
        "    for (int i = 2; i <= n; i++) {",
        "        cur = prev1 + prev2;",
        "        prev2 = prev1;",
        "        prev1 = cur;",
        "    }",
        "    long long ansBU = cur;",
        "    cout << ansBU;",
        "    return 0;",
        "}"
      ],
      "python": [
        "n = int(input())",
        "",
        "from functools import lru_cache",
        "",
        "# Top-Down",
        "@lru_cache(maxsize=None)",
        "def ways_td(k):",
        "    if k == 0:",
        "        return 1",
        "    if k == 1:",
        "        return 1",
        "    return ways_td(k-1) + ways_td(k-2)",
        "",
        "ans_td = ways_td(n)",
        "",
        "# Bottom-Up with O(1) space",
        "if n == 0:",
        "    print(1)",
        "else:",
        "    prev2, prev1 = 1, 1  # f(0), f(1)",
        "    cur = prev1",
        "    for i in range(2, n+1):",
        "        cur = prev1 + prev2",
        "        prev2, prev1 = prev1, cur",
        "    ans_bu = cur",
        "    print(ans_bu)"
      ],
      "java": [
        "import java.util.*;",
        "",
        "public class Main {",
        "    static long[] memo;",
        "",
        "    static long waysTD(int n) {",
        "        if (n == 0) return 1;",
        "        if (n == 1) return 1;",
        "        if (memo[n] != -1) return memo[n];",
        "        return memo[n] = waysTD(n - 1) + waysTD(n - 2);",
        "    }",
        "",
        "    public static void main(String[] args) {",
        "        Scanner sc = new Scanner(System.in);",
        "        int n = sc.nextInt();",
        "",
        "        memo = new long[n + 1];",
        "        Arrays.fill(memo, -1);",
        "        long ansTD = waysTD(n);",
        "",
        "        if (n == 0) {",
        "            System.out.print(1);",
        "            return;",
        "        }",
        "        long prev2 = 1; // f(0)",
        "        long prev1 = 1; // f(1)",
        "        long cur = prev1;",
        "        for (int i = 2; i <= n; i++) {",
        "            cur = prev1 + prev2;",
        "            prev2 = prev1;",
        "            prev1 = cur;",
        "        }",
        "        long ansBU = cur;",
        "        System.out.print(ansBU);",
        "    }",
        "}"
      ]
    },
    "solution_explanation": [
      "The problem is equivalent to counting paths with steps of size 1 or 2.",
      "The recurrence relation is the same as Fibonacci: f(n) = f(n-1) + f(n-2).",
      "Top-Down recursion with memoization avoids recomputing f(k) for any k.",
      "Bottom-Up iterative solution is very space efficient, using only two or three variables.",
      "Time complexity is O(n) and space can be reduced to O(1) for the Bottom-Up version."
    ],
    "dummy_test_cases_explanation": [
      {
        "input": "2",
        "output": "2",
        "explanation": "Two ways: (1+1) or (2)."
      }
    ],
    "tests_industry_standard": [
      {
        "input": "3",
        "expected_output": "3",
        "explanation": "Ways: (1+1+1), (1+2), (2+1)."
      },
      {
        "input": "0",
        "expected_output": "1",
        "explanation": "One way: stay at the base without climbing."
      }
    ],
    "dry_run_explanation": [
      "For n = 3:",
      "f(0) = 1, f(1) = 1.",
      "f(2) = f(1) + f(0) = 1 + 1 = 2.",
      "f(3) = f(2) + f(1) = 2 + 1 = 3.",
      "So total 3 distinct ways to reach step 3."
    ]
  }
]
