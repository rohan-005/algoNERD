[
  {
    "id": 601,
    "category_id": 6,
    "question_title": "Reverse Linked List",
    "question_description": "Given the head of a singly linked list, reverse the list and return the new head. The reversal must be done by changing the next pointers, not by changing data.",
    "question_level": "Level 2",
    "question_category": "Linked List",
    "question_tags": ["linked-list", "reverse", "iterative"],
    "question_theory": [
      "A singly linked list stores each element in a node that points to the next node.",
      "To reverse the list, we need to reverse the direction of all next pointers.",
      "We commonly use three pointers: prev, curr, and next.",
      "At each step, we store the next of curr, redirect curr->next to prev, then move prev and curr forward.",
      "When curr becomes NULL, prev will point to the new head of the reversed list."
    ],
    "question_concept": [
      "Read N and the N node values to build the linked list (head points to first node).",
      "Initialize three pointers: prev = NULL, curr = head, next = NULL.",
      "While curr is not NULL:",
      "  - Store next = curr->next.",
      "  - Set curr->next = prev to reverse pointer.",
      "  - Move prev = curr and curr = next.",
      "After the loop, prev will be the new head. Print the reversed list starting from prev."
    ],
    "question_explanation": [
      "We only change links between nodes and do not allocate new nodes.",
      "The algorithm runs in linear time as each node is visited exactly once.",
      "The extra memory used is constant since only a fixed number of pointers are used.",
      "This problem helps you practice pointer manipulation and understand how linked list structure works internally."
    ],
    "solution": {
      "cpp": [
        "#include <iostream>",
        "using namespace std;",
        "",
        "struct Node {",
        "    int data;",
        "    Node* next;",
        "    Node(int d) {",
        "        data = d;",
        "        next = NULL;",
        "    }",
        "};",
        "",
        "int main() {",
        "    int n;",
        "    cin >> n;",
        "    if (n <= 0) return 0;",
        "",
        "    int x;",
        "    cin >> x;",
        "    Node* head = new Node(x);",
        "    Node* tail = head;",
        "",
        "    for (int i = 1; i < n; i++) {",
        "        cin >> x;",
        "        tail->next = new Node(x);",
        "        tail = tail->next;",
        "    }",
        "",
        "    Node* prev = NULL;",
        "    Node* curr = head;",
        "    Node* nxt = NULL;",
        "",
        "    while (curr != NULL) {",
        "        nxt = curr->next;",
        "        curr->next = prev;",
        "        prev = curr;",
        "        curr = nxt;",
        "    }",
        "",
        "    head = prev;",
        "",
        "    Node* temp = head;",
        "    while (temp != NULL) {",
        "        cout << temp->data << \" \";",
        "        temp = temp->next;",
        "    }",
        "",
        "    return 0;",
        "}"
      ],
      "python": [
        "class Node:",
        "    def __init__(self, d):",
        "        self.data = d",
        "        self.next = None",
        "",
        "n = int(input())",
        "if n > 0:",
        "    values = list(map(int, input().split()))",
        "    head = Node(values[0])",
        "    tail = head",
        "    for x in values[1:]:",
        "        tail.next = Node(x)",
        "        tail = tail.next",
        "",
        "    prev = None",
        "    curr = head",
        "    while curr is not None:",
        "        nxt = curr.next",
        "        curr.next = prev",
        "        prev = curr",
        "        curr = nxt",
        "",
        "    head = prev",
        "",
        "    temp = head",
        "    out = []",
        "    while temp is not None:",
        "        out.append(str(temp.data))",
        "        temp = temp.next",
        "    print(\" \".join(out))"
      ],
      "java": [
        "import java.util.*;",
        "",
        "class Node {",
        "    int data;",
        "    Node next;",
        "    Node(int d) {",
        "        data = d;",
        "        next = null;",
        "    }",
        "}",
        "",
        "public class Main {",
        "    public static void main(String[] args) {",
        "        Scanner sc = new Scanner(System.in);",
        "        int n = sc.nextInt();",
        "        if (n <= 0) return;",
        "",
        "        int x = sc.nextInt();",
        "        Node head = new Node(x);",
        "        Node tail = head;",
        "",
        "        for (int i = 1; i < n; i++) {",
        "            x = sc.nextInt();",
        "            tail.next = new Node(x);",
        "            tail = tail.next;",
        "        }",
        "",
        "        Node prev = null;",
        "        Node curr = head;",
        "        Node nxt;",
        "",
        "        while (curr != null) {",
        "            nxt = curr.next;",
        "            curr.next = prev;",
        "            prev = curr;",
        "            curr = nxt;",
        "        }",
        "",
        "        head = prev;",
        "",
        "        Node temp = head;",
        "        while (temp != null) {",
        "            System.out.print(temp.data + \" \");",
        "            temp = temp.next;",
        "        }",
        "    }",
        "}"
      ]
    },
    "solution_explanation": [
      "We use an iterative approach with three pointers to reverse the list in-place.",
      "At each step, we reverse one link and move forward, so total operations are proportional to the number of nodes.",
      "Time complexity is O(N) where N is the number of nodes.",
      "Space complexity is O(1) because no extra data structures are allocated apart from a few pointers."
    ],
    "dummy_test_cases_explanation": [
      {
        "input": "5\n10 20 30 40 50",
        "output": "50 40 30 20 10",
        "explanation": "The original list 10→20→30→40→50 becomes 50→40→30→20→10 after reversing all links."
      }
    ],
    "tests_industry_standard": [
      {
        "input": "1\n42",
        "expected_output": "42",
        "explanation": "Single-node list remains the same after reversal."
      },
      {
        "input": "4\n1 2 3 4",
        "expected_output": "4 3 2 1",
        "explanation": "Checks multi-node reversal and correct order."
      }
    ],
    "dry_run_explanation": [
      "Consider list: 1→2→3",
      "Start: prev = NULL, curr = 1",
      "Step 1: nxt = 2, 1->next = NULL, prev = 1, curr = 2",
      "Step 2: nxt = 3, 2->next = 1, prev = 2, curr = 3",
      "Step 3: nxt = NULL, 3->next = 2, prev = 3, curr = NULL",
      "End: head = prev = 3, result list: 3→2→1"
    ]
  },
  {
    "id": 602,
    "category_id": 6,
    "question_title": "Detect Loop in Linked List",
    "question_description": "Given the head of a singly linked list, determine whether the list contains a cycle (loop). Use Floyd's Tortoise and Hare (slow and fast pointers) algorithm.",
    "question_level": "Level 2",
    "question_category": "Linked List",
    "question_tags": ["linked-list", "cycle", "floyd", "two-pointers"],
    "question_theory": [
      "A loop in a linked list occurs when a node's next pointer points back to some previous node instead of NULL.",
      "Floyd's Cycle Detection Algorithm uses two pointers: slow and fast.",
      "Slow pointer moves one step at a time while fast pointer moves two steps.",
      "If there is a loop, slow and fast will eventually meet at some node inside the cycle.",
      "If fast reaches NULL (end of list), then there is no loop."
    ],
    "question_concept": [
      "Initialize slow = head and fast = head.",
      "While fast and fast->next are not NULL:",
      "  - Move slow one step: slow = slow->next",
      "  - Move fast two steps: fast = fast->next->next",
      "  - If slow == fast at any point: loop exists.",
      "If the loop finishes without meeting, there is no loop."
    ],
    "question_explanation": [
      "The fast pointer moves twice as quickly as the slow pointer.",
      "If the list has a cycle, the difference in speeds guarantees that fast will lap slow and they will meet.",
      "If the list is acyclic, fast will eventually reach NULL and we know there is no cycle.",
      "This algorithm uses constant extra space and linear time."
    ],
    "solution": {
      "cpp": [
        "#include <iostream>",
        "using namespace std;",
        "",
        "struct Node {",
        "    int data;",
        "    Node* next;",
        "    Node(int d) {",
        "        data = d;",
        "        next = NULL;",
        "    }",
        "};",
        "",
        "bool hasLoop(Node* head) {",
        "    Node* slow = head;",
        "    Node* fast = head;",
        "    while (fast != NULL && fast->next != NULL) {",
        "        slow = slow->next;",
        "        fast = fast->next->next;",
        "        if (slow == fast) return true;",
        "    }",
        "    return false;",
        "}",
        "",
        "int main() {",
        "    int n;",
        "    cin >> n;",
        "    if (n <= 0) {",
        "        cout << \"No Loop\";",
        "        return 0;",
        "    }",
        "",
        "    int x;",
        "    cin >> x;",
        "    Node* head = new Node(x);",
        "    Node* tail = head;",
        "",
        "    for (int i = 1; i < n; i++) {",
        "        cin >> x;",
        "        tail->next = new Node(x);",
        "        tail = tail->next;",
        "    }",
        "",
        "    int makeLoop;",
        "    cin >> makeLoop;  // 0 = no loop, 1 = connect tail to head",
        "",
        "    if (makeLoop == 1) {",
        "        tail->next = head;  // simple loop for testing",
        "    }",
        "",
        "    if (hasLoop(head)) cout << \"Loop Found\";",
        "    else cout << \"No Loop\";",
        "",
        "    return 0;",
        "}"
      ],
      "python": [
        "class Node:",
        "    def __init__(self, d):",
        "        self.data = d",
        "        self.next = None",
        "",
        "def has_loop(head):",
        "    slow = head",
        "    fast = head",
        "    while fast is not None and fast.next is not None:",
        "        slow = slow.next",
        "        fast = fast.next.next",
        "        if slow == fast:",
        "            return True",
        "    return False",
        "",
        "n = int(input())",
        "if n <= 0:",
        "    print(\"No Loop\")",
        "else:",
        "    values = list(map(int, input().split()))",
        "    head = Node(values[0])",
        "    tail = head",
        "    for x in values[1:]:",
        "        tail.next = Node(x)",
        "        tail = tail.next",
        "",
        "    make_loop = int(input())  # 0 or 1",
        "    if make_loop == 1:",
        "        tail.next = head",
        "",
        "    print(\"Loop Found\" if has_loop(head) else \"No Loop\")"
      ],
      "java": [
        "import java.util.*;",
        "",
        "class Node {",
        "    int data;",
        "    Node next;",
        "    Node(int d) {",
        "        data = d;",
        "        next = null;",
        "    }",
        "}",
        "",
        "public class Main {",
        "    static boolean hasLoop(Node head) {",
        "        Node slow = head;",
        "        Node fast = head;",
        "        while (fast != null && fast.next != null) {",
        "            slow = slow.next;",
        "            fast = fast.next.next;",
        "            if (slow == fast) return true;",
        "        }",
        "        return false;",
        "    }",
        "",
        "    public static void main(String[] args) {",
        "        Scanner sc = new Scanner(System.in);",
        "        int n = sc.nextInt();",
        "        if (n <= 0) {",
        "            System.out.println(\"No Loop\");",
        "            return;",
        "        }",
        "",
        "        int x = sc.nextInt();",
        "        Node head = new Node(x);",
        "        Node tail = head;",
        "",
        "        for (int i = 1; i < n; i++) {",
        "            x = sc.nextInt();",
        "            tail.next = new Node(x);",
        "            tail = tail.next;",
        "        }",
        "",
        "        int makeLoop = sc.nextInt();  // 0 or 1",
        "        if (makeLoop == 1) {",
        "            tail.next = head;",
        "        }",
        "",
        "        System.out.println(hasLoop(head) ? \"Loop Found\" : \"No Loop\");",
        "    }",
        "}"
      ]
    },
    "solution_explanation": [
      "Floyd's algorithm uses two pointers that move at different speeds to detect cycles.",
      "If there is a loop, the fast pointer will eventually meet the slow pointer inside the loop.",
      "If the list has no loop, the fast pointer will reach the end (NULL) and the function returns false.",
      "The algorithm runs in O(N) time and uses O(1) extra memory."
    ],
    "dummy_test_cases_explanation": [
      {
        "input": "5\n1 2 3 4 5\n1",
        "output": "Loop Found",
        "explanation": "The last node is connected back to the head, forming a loop. Floyd's algorithm detects the meeting point."
      },
      {
        "input": "4\n10 20 30 40\n0",
        "output": "No Loop",
        "explanation": "No connection is made back, so the list is linear and has no cycle."
      }
    ],
    "tests_industry_standard": [
      {
        "input": "1\n100\n0",
        "expected_output": "No Loop",
        "explanation": "Single-node list without loop should be detected as no loop."
      },
      {
        "input": "1\n100\n1",
        "expected_output": "Loop Found",
        "explanation": "Single-node list whose next points to itself forms a loop."
      }
    ],
    "dry_run_explanation": [
      "Example: 1→2→3→4→2 (loop back to node with value 2).",
      "Initial: slow = 1, fast = 1.",
      "Step 1: slow = 2, fast = 3.",
      "Step 2: slow = 3, fast = 2.",
      "Step 3: slow = 4, fast = 4 → slow == fast, loop detected."
    ]
  },
  {
    "id": 603,
    "category_id": 6,
    "question_title": "Find Middle Node",
    "question_description": "Given the head of a singly linked list, find and print the value of the middle node. If there are two middle nodes (even length), print the second one.",
    "question_level": "Level 1",
    "question_category": "Linked List",
    "question_tags": ["linked-list", "two-pointers"],
    "question_theory": [
      "We use two pointers: slow and fast.",
      "Slow moves one step at a time, fast moves two steps at a time.",
      "When fast reaches the end (fast == NULL or fast->next == NULL), slow is at the middle.",
      "For even-length lists, this approach gives the second middle by design."
    ],
    "question_concept": [
      "Read N and build the linked list.",
      "Initialize slow = head and fast = head.",
      "Move slow by one node and fast by two nodes until fast reaches the end.",
      "When the loop ends, slow points to the middle node.",
      "Print slow->data."
    ],
    "question_explanation": [
      "The fast pointer traverses the list twice as fast as the slow pointer.",
      "Thus, when fast finishes all nodes, slow has only traversed half of them.",
      "This technique avoids counting nodes or using extra memory.",
      "The algorithm is widely used in various linked list problems."
    ],
    "solution": {
      "cpp": [
        "#include <iostream>",
        "using namespace std;",
        "",
        "struct Node {",
        "    int data;",
        "    Node* next;",
        "    Node(int d) {",
        "        data = d;",
        "        next = NULL;",
        "    }",
        "};",
        "",
        "int main() {",
        "    int n;",
        "    cin >> n;",
        "    if (n <= 0) return 0;",
        "",
        "    int x;",
        "    cin >> x;",
        "    Node* head = new Node(x);",
        "    Node* tail = head;",
        "",
        "    for (int i = 1; i < n; i++) {",
        "        cin >> x;",
        "        tail->next = new Node(x);",
        "        tail = tail->next;",
        "    }",
        "",
        "    Node* slow = head;",
        "    Node* fast = head;",
        "",
        "    while (fast != NULL && fast->next != NULL) {",
        "        slow = slow->next;",
        "        fast = fast->next->next;",
        "    }",
        "",
        "    cout << slow->data;",
        "",
        "    return 0;",
        "}"
      ],
      "python": [
        "class Node:",
        "    def __init__(self, d):",
        "        self.data = d",
        "        self.next = None",
        "",
        "n = int(input())",
        "if n > 0:",
        "    values = list(map(int, input().split()))",
        "    head = Node(values[0])",
        "    tail = head",
        "    for x in values[1:]:",
        "        tail.next = Node(x)",
        "        tail = tail.next",
        "",
        "    slow = head",
        "    fast = head",
        "    while fast is not None and fast.next is not None:",
        "        slow = slow.next",
        "        fast = fast.next.next",
        "",
        "    print(slow.data)"
      ],
      "java": [
        "import java.util.*;",
        "",
        "class Node {",
        "    int data;",
        "    Node next;",
        "    Node(int d) {",
        "        data = d;",
        "        next = null;",
        "    }",
        "}",
        "",
        "public class Main {",
        "    public static void main(String[] args) {",
        "        Scanner sc = new Scanner(System.in);",
        "        int n = sc.nextInt();",
        "        if (n <= 0) return;",
        "",
        "        int x = sc.nextInt();",
        "        Node head = new Node(x);",
        "        Node tail = head;",
        "",
        "        for (int i = 1; i < n; i++) {",
        "            x = sc.nextInt();",
        "            tail.next = new Node(x);",
        "            tail = tail.next;",
        "        }",
        "",
        "        Node slow = head;",
        "        Node fast = head;",
        "",
        "        while (fast != null && fast.next != null) {",
        "            slow = slow.next;",
        "            fast = fast.next.next;",
        "        }",
        "",
        "        System.out.println(slow.data);",
        "    }",
        "}"
      ]
    },
    "solution_explanation": [
      "We traverse the list only once using two pointers.",
      "Fast pointer moves twice as quickly as slow, so slow ends at the middle.",
      "Time complexity is O(N) and space complexity is O(1).",
      "The method works for both odd and even length lists."
    ],
    "dummy_test_cases_explanation": [
      {
        "input": "5\n1 2 3 4 5",
        "output": "3",
        "explanation": "The list is 1→2→3→4→5, so the middle node is 3."
      }
    ],
    "tests_industry_standard": [
      {
        "input": "4\n10 20 30 40",
        "expected_output": "30",
        "explanation": "Even length list; the two middle nodes are 20 and 30, but we choose the second one."
      },
      {
        "input": "1\n99",
        "expected_output": "99",
        "explanation": "Single node is trivially the middle."
      }
    ],
    "dry_run_explanation": [
      "Example list: 1→2→3→4→5",
      "Initially: slow=1, fast=1.",
      "Iteration 1: slow=2, fast=3.",
      "Iteration 2: slow=3, fast=5.",
      "Iteration 3: fast->next is NULL, loop stops, slow is at node 3 (middle)."
    ]
  },
  {
    "id": 604,
    "category_id": 6,
    "question_title": "Merge Two Sorted Linked Lists",
    "question_description": "Given the heads of two sorted singly linked lists, merge them into a single sorted linked list and print the merged list.",
    "question_level": "Level 2",
    "question_category": "Linked List",
    "question_tags": ["linked-list", "merge", "two-pointers"],
    "question_theory": [
      "Merging two sorted linked lists is similar to the merge step of merge sort.",
      "At each step, we compare the current node values of both lists.",
      "We attach the smaller node to the result list and move that list's pointer forward.",
      "We continue until one list ends, then append the remaining nodes of the other list."
    ],
    "question_concept": [
      "Read N1 and build the first sorted linked list.",
      "Read N2 and build the second sorted linked list.",
      "Maintain a dummy head pointer to simplify merging.",
      "Use two pointers p1 and p2 that traverse list1 and list2.",
      "Compare p1->data and p2->data, attach the smaller to the current tail of the new list.",
      "When one list finishes, attach the remaining nodes of the other list.",
      "Print the merged list."
    ],
    "question_explanation": [
      "We never reorder nodes by swapping data; we only rewire next pointers.",
      "Using a dummy head avoids special cases for the first element.",
      "This is a standard pattern used in many linked list problems."
    ],
    "solution": {
      "cpp": [
        "#include <iostream>",
        "using namespace std;",
        "",
        "struct Node {",
        "    int data;",
        "    Node* next;",
        "    Node(int d) {",
        "        data = d;",
        "        next = NULL;",
        "    }",
        "};",
        "",
        "Node* buildList(int n) {",
        "    if (n <= 0) return NULL;",
        "    int x;",
        "    cin >> x;",
        "    Node* head = new Node(x);",
        "    Node* tail = head;",
        "    for (int i = 1; i < n; i++) {",
        "        cin >> x;",
        "        tail->next = new Node(x);",
        "        tail = tail->next;",
        "    }",
        "    return head;",
        "}",
        "",
        "int main() {",
        "    int n1, n2;",
        "    cin >> n1;",
        "    Node* head1 = buildList(n1);",
        "    cin >> n2;",
        "    Node* head2 = buildList(n2);",
        "",
        "    Node dummy(0);",
        "    Node* tail = &dummy;",
        "    Node* p1 = head1;",
        "    Node* p2 = head2;",
        "",
        "    while (p1 != NULL && p2 != NULL) {",
        "        if (p1->data <= p2->data) {",
        "            tail->next = p1;",
        "            p1 = p1->next;",
        "        } else {",
        "            tail->next = p2;",
        "            p2 = p2->next;",
        "        }",
        "        tail = tail->next;",
        "    }",
        "",
        "    if (p1 != NULL) tail->next = p1;",
        "    else if (p2 != NULL) tail->next = p2;",
        "",
        "    Node* curr = dummy.next;",
        "    while (curr != NULL) {",
        "        cout << curr->data << \" \";",
        "        curr = curr->next;",
        "    }",
        "",
        "    return 0;",
        "}"
      ],
      "python": [
        "class Node:",
        "    def __init__(self, d):",
        "        self.data = d",
        "        self.next = None",
        "",
        "def build_list(n):",
        "    if n <= 0:",
        "        return None",
        "    values = list(map(int, input().split()))",
        "    head = Node(values[0])",
        "    tail = head",
        "    for x in values[1:]:",
        "        tail.next = Node(x)",
        "        tail = tail.next",
        "    return head",
        "",
        "def merge(head1, head2):",
        "    dummy = Node(0)",
        "    tail = dummy",
        "    p1 = head1",
        "    p2 = head2",
        "    while p1 is not None and p2 is not None:",
        "        if p1.data <= p2.data:",
        "            tail.next = p1",
        "            p1 = p1.next",
        "        else:",
        "            tail.next = p2",
        "            p2 = p2.next",
        "        tail = tail.next",
        "    if p1 is not None:",
        "        tail.next = p1",
        "    else:",
        "        tail.next = p2",
        "    return dummy.next",
        "",
        "n1 = int(input())",
        "head1 = build_list(n1)",
        "n2 = int(input())",
        "head2 = build_list(n2)",
        "",
        "merged = merge(head1, head2)",
        "out = []",
        "curr = merged",
        "while curr is not None:",
        "    out.append(str(curr.data))",
        "    curr = curr.next",
        "print(\" \".join(out))"
      ],
      "java": [
        "import java.util.*;",
        "",
        "class Node {",
        "    int data;",
        "    Node next;",
        "    Node(int d) {",
        "        data = d;",
        "        next = null;",
        "    }",
        "}",
        "",
        "public class Main {",
        "    static Node buildList(Scanner sc, int n) {",
        "        if (n <= 0) return null;",
        "        int x = sc.nextInt();",
        "        Node head = new Node(x);",
        "        Node tail = head;",
        "        for (int i = 1; i < n; i++) {",
        "            x = sc.nextInt();",
        "            tail.next = new Node(x);",
        "            tail = tail.next;",
        "        }",
        "        return head;",
        "    }",
        "",
        "    public static void main(String[] args) {",
        "        Scanner sc = new Scanner(System.in);",
        "        int n1 = sc.nextInt();",
        "        Node head1 = buildList(sc, n1);",
        "        int n2 = sc.nextInt();",
        "        Node head2 = buildList(sc, n2);",
        "",
        "        Node dummy = new Node(0);",
        "        Node tail = dummy;",
        "        Node p1 = head1;",
        "        Node p2 = head2;",
        "",
        "        while (p1 != null && p2 != null) {",
        "            if (p1.data <= p2.data) {",
        "                tail.next = p1;",
        "                p1 = p1.next;",
        "            } else {",
        "                tail.next = p2;",
        "                p2 = p2.next;",
        "            }",
        "            tail = tail.next;",
        "        }",
        "",
        "        if (p1 != null) tail.next = p1;",
        "        else if (p2 != null) tail.next = p2;",
        "",
        "        Node curr = dummy.next;",
        "        while (curr != null) {",
        "            System.out.print(curr.data + \" \");",
        "            curr = curr.next;",
        "        }",
        "    }",
        "}"
      ]
    },
    "solution_explanation": [
      "We maintain pointers into both lists and always choose the smaller current element.",
      "Using a dummy head simplifies appending to the result list.",
      "We never create new nodes except the dummy; we reuse the existing nodes.",
      "Time complexity is O(N1 + N2), space complexity is O(1) extra."
    ],
    "dummy_test_cases_explanation": [
      {
        "input": "3\n1 3 5\n3\n2 4 6",
        "output": "1 2 3 4 5 6",
        "explanation": "Both lists are already sorted, merged list maintains sorted order."
      }
    ],
    "tests_industry_standard": [
      {
        "input": "3\n1 2 3\n2\n4 5",
        "expected_output": "1 2 3 4 5",
        "explanation": "All elements of first list are smaller and appear first."
      },
      {
        "input": "0\n\n3\n10 20 30",
        "expected_output": "10 20 30",
        "explanation": "First list is empty, so result is just second list."
      }
    ],
    "dry_run_explanation": [
      "List1: 1→3→5, List2: 2→4→6",
      "Compare 1 and 2 → take 1",
      "Compare 3 and 2 → take 2",
      "Compare 3 and 4 → take 3",
      "Compare 5 and 4 → take 4",
      "Compare 5 and 6 → take 5",
      "Remaining: 6 → append",
      "Result: 1→2→3→4→5→6"
    ]
  },
  {
    "id": 605,
    "category_id": 6,
    "question_title": "Remove Nth Node from End of Linked List",
    "question_description": "Given the head of a singly linked list and an integer N, remove the Nth node from the end of the list and print the updated list.",
    "question_level": "Level 2",
    "question_category": "Linked List",
    "question_tags": ["linked-list", "two-pointers"],
    "question_theory": [
      "A common technique is to use two pointers with a fixed gap between them.",
      "First, we move the fast pointer N steps ahead.",
      "Then we move both slow and fast pointers together until fast reaches the last node.",
      "Slow will then point to the node just before the one that needs to be deleted.",
      "Using a dummy node before head simplifies the edge case of removing the first node."
    ],
    "question_concept": [
      "Read N and build the linked list.",
      "Create a dummy node whose next points to head.",
      "Set slow = dummy and fast = dummy.",
      "Move fast pointer N steps forward.",
      "Move both slow and fast one step at a time until fast->next is NULL.",
      "Now slow->next is the node to be removed.",
      "Set slow->next = slow->next->next to skip that node.",
      "Print the updated list starting from dummy->next."
    ],
    "question_explanation": [
      "Using a dummy node avoids writing separate logic for deleting the head.",
      "The two-pointer approach ensures we don't need to count the length of the list separately.",
      "All operations are done in a single traversal of the list."
    ],
    "solution": {
      "cpp": [
        "#include <iostream>",
        "using namespace std;",
        "",
        "struct Node {",
        "    int data;",
        "    Node* next;",
        "    Node(int d) {",
        "        data = d;",
        "        next = NULL;",
        "    }",
        "};",
        "",
        "int main() {",
        "    int n;",
        "    cin >> n;",
        "    if (n <= 0) return 0;",
        "",
        "    int x;",
        "    cin >> x;",
        "    Node* head = new Node(x);",
        "    Node* tail = head;",
        "",
        "    for (int i = 1; i < n; i++) {",
        "        cin >> x;",
        "        tail->next = new Node(x);",
        "        tail = tail->next;",
        "    }",
        "",
        "    int k;",
        "    cin >> k;",
        "",
        "    Node dummy(0);",
        "    dummy.next = head;",
        "    Node* slow = &dummy;",
        "    Node* fast = &dummy;",
        "",
        "    for (int i = 0; i < k; i++) {",
        "        if (fast->next == NULL) {",
        "            // k is larger than length, nothing to remove",
        "            cout << head->data << \" \";",
        "            Node* t = head->next;",
        "            while (t != NULL) {",
        "                cout << t->data << \" \";",
        "                t = t->next;",
        "            }",
        "            return 0;",
        "        }",
        "        fast = fast->next;",
        "    }",
        "",
        "    while (fast->next != NULL) {",
        "        fast = fast->next;",
        "        slow = slow->next;",
        "    }",
        "",
        "    Node* toDelete = slow->next;",
        "    if (toDelete != NULL) slow->next = toDelete->next;",
        "",
        "    head = dummy.next;",
        "",
        "    Node* curr = head;",
        "    while (curr != NULL) {",
        "        cout << curr->data << \" \";",
        "        curr = curr->next;",
        "    }",
        "",
        "    return 0;",
        "}"
      ],
      "python": [
        "class Node:",
        "    def __init__(self, d):",
        "        self.data = d",
        "        self.next = None",
        "",
        "n = int(input())",
        "if n > 0:",
        "    values = list(map(int, input().split()))",
        "    head = Node(values[0])",
        "    tail = head",
        "    for x in values[1:]:",
        "        tail.next = Node(x)",
        "        tail = tail.next",
        "",
        "    k = int(input())",
        "",
        "    dummy = Node(0)",
        "    dummy.next = head",
        "    slow = dummy",
        "    fast = dummy",
        "",
        "    for _ in range(k):",
        "        if fast.next is None:",
        "            break",
        "        fast = fast.next",
        "",
        "    while fast.next is not None:",
        "        fast = fast.next",
        "        slow = slow.next",
        "",
        "    if slow.next is not None:",
        "        slow.next = slow.next.next",
        "",
        "    head = dummy.next",
        "    curr = head",
        "    out = []",
        "    while curr is not None:",
        "        out.append(str(curr.data))",
        "        curr = curr.next",
        "    print(\" \".join(out))"
      ],
      "java": [
        "import java.util.*;",
        "",
        "class Node {",
        "    int data;",
        "    Node next;",
        "    Node(int d) {",
        "        data = d;",
        "        next = null;",
        "    }",
        "}",
        "",
        "public class Main {",
        "    public static void main(String[] args) {",
        "        Scanner sc = new Scanner(System.in);",
        "        int n = sc.nextInt();",
        "        if (n <= 0) return;",
        "",
        "        int x = sc.nextInt();",
        "        Node head = new Node(x);",
        "        Node tail = head;",
        "",
        "        for (int i = 1; i < n; i++) {",
        "            x = sc.nextInt();",
        "            tail.next = new Node(x);",
        "            tail = tail.next;",
        "        }",
        "",
        "        int k = sc.nextInt();",
        "",
        "        Node dummy = new Node(0);",
        "        dummy.next = head;",
        "        Node slow = dummy;",
        "        Node fast = dummy;",
        "",
        "        for (int i = 0; i < k; i++) {",
        "            if (fast.next == null) break;",
        "            fast = fast.next;",
        "        }",
        "",
        "        while (fast.next != null) {",
        "            fast = fast.next;",
        "            slow = slow.next;",
        "        }",
        "",
        "        if (slow.next != null) slow.next = slow.next.next;",
        "",
        "        head = dummy.next;",
        "",
        "        Node curr = head;",
        "        while (curr != null) {",
        "            System.out.print(curr.data + \" \");",
        "            curr = curr.next;",
        "        }",
        "    }",
        "}"
      ]
    },
    "solution_explanation": [
      "We use a dummy node to unify handling of deleting the head and other nodes.",
      "By moving fast k steps ahead, the gap between slow and fast becomes k nodes.",
      "When fast reaches the last node, slow is just before the node we want to delete.",
      "We then relink slow->next to skip the target node.",
      "Time complexity is O(N), space complexity is O(1)."
    ],
    "dummy_test_cases_explanation": [
      {
        "input": "5\n10 20 30 40 50\n2",
        "output": "10 20 30 50",
        "explanation": "The 2nd node from the end is 40; after removal, the list becomes 10 20 30 50."
      }
    ],
    "tests_industry_standard": [
      {
        "input": "1\n99\n1",
        "expected_output": "",
        "explanation": "Removing the only node in the list results in an empty list (no output)."
      },
      {
        "input": "4\n1 2 3 4\n4",
        "expected_output": "2 3 4",
        "explanation": "Removing 4th node from end is same as removing the head node (1)."
      }
    ],
    "dry_run_explanation": [
      "Example: List = 10→20→30→40→50, k = 2",
      "We create dummy→10→20→30→40→50.",
      "Move fast 2 steps: fast at 20.",
      "Then move both until fast->next is NULL:",
      "  Step 1: fast=30, slow=10",
      "  Step 2: fast=40, slow=20",
      "  Step 3: fast=50, slow=30",
      "Now slow->next is 40 (node to remove).",
      "Relink slow->next = slow->next->next = 50.",
      "Final list: 10→20→30→50."
    ]
  }
]
