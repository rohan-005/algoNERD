[
    {
  "id": 901,
  "category_id": 9,
  "question_title": "Binary Tree Traversals",
  "question_description": "Given a binary tree, print its Preorder, Inorder, and Postorder traversals. Input is given as level order, where -1 represents a NULL node.",
  "question_level": "Level 2",
  "question_category": "Tree",
  "question_tags": ["tree", "dfs", "recursion", "traversal"],
  "question_theory": [
    "A Binary Tree is a hierarchical data structure where each node has at most two children: left and right.",
    "Depth First Traversal (DFS) uses recursion to explore nodes deeply before backtracking.",
    "Three major DFS traversals:",
    "1️⃣ Preorder: Root → Left → Right",
    "2️⃣ Inorder: Left → Root → Right",
    "3️⃣ Postorder: Left → Right → Root",
    "Different traversals serve different applications such as serialization, expression trees, sorting, etc."
  ],
  "question_concept": [
    "Read N and N node values in level order.",
    "Use a queue to construct the tree:",
    " - Start by creating root from first element.",
    " - For each node, assign left and right using next values.",
    " - If value is -1, skip child creation.",
    "Recursively perform three types of DFS:",
    " - preorder(root)",
    " - inorder(root)",
    " - postorder(root)"
  ],
  "question_explanation": [
    "DFS recursion ensures all nodes are visited exactly once.",
    "Traversal order defines different applications:",
    " - Preorder: Used to create copies of tree",
    " - Inorder: Gives sorted order in BST",
    " - Postorder: Used for deletion/tree-freeing"
  ],
  "solution": {
    "cpp": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "struct Node {",
      "    int data;",
      "    Node* left;",
      "    Node* right;",
      "    Node(int val) : data(val), left(NULL), right(NULL) {}",
      "};",
      "",
      "Node* buildTree(vector<int> &arr) {",
      "    if(arr.empty() || arr[0] == -1) return NULL;",
      "    Node* root = new Node(arr[0]);",
      "    queue<Node*> q;",
      "    q.push(root);",
      "    int i = 1;",
      "    while(i < arr.size()) {",
      "        Node* curr = q.front(); q.pop();",
      "",
      "        if(arr[i] != -1) {",
      "            curr->left = new Node(arr[i]);",
      "            q.push(curr->left);",
      "        }",
      "        i++;",
      "",
      "        if(i < arr.size() && arr[i] != -1) {",
      "            curr->right = new Node(arr[i]);",
      "            q.push(curr->right);",
      "        }",
      "        i++;",
      "    }",
      "    return root;",
      "}",
      "",
      "void preorder(Node* root) {",
      "    if(!root) return;",
      "    cout << root->data << \" \";",
      "    preorder(root->left);",
      "    preorder(root->right);",
      "}",
      "",
      "void inorder(Node* root) {",
      "    if(!root) return;",
      "    inorder(root->left);",
      "    cout << root->data << \" \";",
      "    inorder(root->right);",
      "}",
      "",
      "void postorder(Node* root) {",
      "    if(!root) return;",
      "    postorder(root->left);",
      "    postorder(root->right);",
      "    cout << root->data << \" \";",
      "}",
      "",
      "int main() {",
      "    int n; cin >> n;",
      "    vector<int> arr(n);",
      "    for(int i=0;i<n;i++) cin >> arr[i];",
      "    Node* root = buildTree(arr);",
      "",
      "    preorder(root); cout << endl;",
      "    inorder(root); cout << endl;",
      "    postorder(root); cout << endl;",
      "    return 0;",
      "}"
    ],
    "python": [
      "from collections import deque",
      "",
      "class Node:",
      "    def __init__(self, val):",
      "        self.data = val",
      "        self.left = None",
      "        self.right = None",
      "",
      "def buildTree(arr):",
      "    if not arr or arr[0] == -1:",
      "        return None",
      "    root = Node(arr[0])",
      "    q = deque([root])",
      "    i = 1",
      "    while q and i < len(arr):",
      "        curr = q.popleft()",
      "        if arr[i] != -1:",
      "            curr.left = Node(arr[i])",
      "            q.append(curr.left)",
      "        i += 1",
      "        if i < len(arr) and arr[i] != -1:",
      "            curr.right = Node(arr[i])",
      "            q.append(curr.right)",
      "        i += 1",
      "    return root",
      "",
      "def preorder(root):",
      "    if not root: return",
      "    print(root.data, end=' ')",
      "    preorder(root.left)",
      "    preorder(root.right)",
      "",
      "def inorder(root):",
      "    if not root: return",
      "    inorder(root.left)",
      "    print(root.data, end=' ')",
      "    inorder(root.right)",
      "",
      "def postorder(root):",
      "    if not root: return",
      "    postorder(root.left)",
      "    postorder(root.right)",
      "    print(root.data, end=' ')",
      "",
      "n = int(input())",
      "arr = list(map(int, input().split()))",
      "root = buildTree(arr)",
      "",
      "preorder(root); print()",
      "inorder(root); print()",
      "postorder(root)"
    ],
    "java": [
      "import java.util.*;",
      "",
      "class Node {",
      "    int data;",
      "    Node left, right;",
      "    Node(int val) { data = val; }",
      "}",
      "",
      "public class Main {",
      "    static Node buildTree(int[] arr) {",
      "        if(arr.length == 0 || arr[0] == -1) return null;",
      "        Node root = new Node(arr[0]);",
      "        Queue<Node> q = new LinkedList<>();",
      "        q.add(root);",
      "        int i = 1;",
      "        while(i < arr.length) {",
      "            Node curr = q.poll();",
      "            if(arr[i] != -1) {",
      "                curr.left = new Node(arr[i]);",
      "                q.add(curr.left);",
      "            }",
      "            i++;",
      "            if(i < arr.length && arr[i] != -1) {",
      "                curr.right = new Node(arr[i]);",
      "                q.add(curr.right);",
      "            }",
      "            i++;",
      "        }",
      "        return root;",
      "    }",
      "",
      "    static void preorder(Node root) {",
      "        if(root == null) return;",
      "        System.out.print(root.data + \" \");",
      "        preorder(root.left);",
      "        preorder(root.right);",
      "    }",
      "",
      "    static void inorder(Node root) {",
      "        if(root == null) return;",
      "        inorder(root.left);",
      "        System.out.print(root.data + \" \");",
      "        inorder(root.right);",
      "    }",
      "",
      "    static void postorder(Node root) {",
      "        if(root == null) return;",
      "        postorder(root.left);",
      "        postorder(root.right);",
      "        System.out.print(root.data + \" \");",
      "    }",
      "",
      "    public static void main(String[] args) {",
      "        Scanner sc = new Scanner(System.in);",
      "        int n = sc.nextInt();",
      "        int[] arr = new int[n];",
      "        for(int i=0;i<n;i++) arr[i] = sc.nextInt();",
      "        Node root = buildTree(arr);",
      "        preorder(root); System.out.println();",
      "        inorder(root); System.out.println();",
      "        postorder(root);",
      "    }",
      "}"
    ]
  },
  "solution_explanation": [
    "DFS traversal visits all nodes exactly once → O(N).",
    "Recursion handles tree structure easily with call stack.",
    "Postorder is especially useful when freeing tree memory or expression evaluation."
  ],
  "dummy_test_cases_explanation": [
    {
      "input": "7\n1 2 3 4 5 -1 6",
      "output": "Preorder: 1 2 4 5 3 6\nInorder: 4 2 5 1 3 6\nPostorder: 4 5 2 6 3 1",
      "explanation": "DFS patterns verified on a typical binary tree."
    }
  ],
  "tests_industry_standard": [
    {
      "input": "3\n1 2 3",
      "expected_output": "Preorder: 1 2 3\nInorder: 2 1 3\nPostorder: 2 3 1",
      "explanation": "Complete tree of height 1"
    },
    {
      "input": "5\n1 2 -1 3 -1",
      "expected_output": "Preorder: 1 2 3\nInorder: 3 2 1\nPostorder: 3 2 1",
      "explanation": "Skewed left tree validation"
    }
  ],
  "dry_run_explanation": [
    "Example: 1 2 3 4 5 -1 6",
    "Preorder visits: Root → Left → Right",
    "Traversal order based on input tree structure gives expected sequences"
  ]
},
{
  "id": 902,
  "category_id": 9,
  "question_title": "Level Order Traversal",
  "question_description": "Given a binary tree, print its level order traversal (Breadth First Traversal). Input is given in level order where -1 represents NULL nodes.",
  "question_level": "Level 2",
  "question_category": "Tree",
  "question_tags": ["tree", "bfs", "queue"],
  "question_theory": [
    "BFS (Breadth First Search) visits nodes level by level from left to right.",
    "We use a queue to store nodes of the current level while adding nodes of the next level.",
    "Level Order Traversal prints nodes in the exact order they appear in a perfect layered layout."
  ],
  "question_concept": [
    "Use the same tree construction logic from Question 901.",
    "Initialize a queue with the root node.",
    "Process nodes in FIFO order:",
    " - Print front node",
    " - Push its left child (if exists)",
    " - Push its right child (if exists)",
    "Continue until queue is empty."
  ],
  "question_explanation": [
    "Queue ensures first-come first-out (FIFO) order of nodes.",
    "All nodes are visited exactly once → O(N) time.",
    "Works even for skewed trees and trees with missing children (-1 nodes)."
  ],
  "solution": {
    "cpp": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "struct Node {",
      "    int data;",
      "    Node* left;",
      "    Node* right;",
      "    Node(int v) : data(v), left(NULL), right(NULL) {}",
      "};",
      "",
      "Node* buildTree(vector<int> &arr) {",
      "    if(arr.empty() || arr[0] == -1) return NULL;",
      "    Node* root = new Node(arr[0]);",
      "    queue<Node*> q;",
      "    q.push(root);",
      "    int i = 1;",
      "    while(i < arr.size()) {",
      "        Node* curr = q.front(); q.pop();",
      "        if(arr[i] != -1) {",
      "            curr->left = new Node(arr[i]);",
      "            q.push(curr->left);",
      "        }",
      "        i++;",
      "        if(i < arr.size() && arr[i] != -1) {",
      "            curr->right = new Node(arr[i]);",
      "            q.push(curr->right);",
      "        }",
      "        i++;",
      "    }",
      "    return root;",
      "}",
      "",
      "int main() {",
      "    int n; cin >> n;",
      "    vector<int> arr(n);",
      "    for(int i=0; i<n; i++) cin >> arr[i];",
      "    Node* root = buildTree(arr);",
      "",
      "    queue<Node*> q;",
      "    if(root) q.push(root);",
      "    while(!q.empty()) {",
      "        Node* curr = q.front(); q.pop();",
      "        cout << curr->data << \" \";",
      "        if(curr->left) q.push(curr->left);",
      "        if(curr->right) q.push(curr->right);",
      "    }",
      "    return 0;",
      "}"
    ],
    "python": [
      "from collections import deque",
      "",
      "class Node:",
      "    def __init__(self, v):",
      "        self.data = v",
      "        self.left = None",
      "        self.right = None",
      "",
      "def buildTree(arr):",
      "    if not arr or arr[0] == -1:",
      "        return None",
      "    root = Node(arr[0])",
      "    q = deque([root])",
      "    i = 1",
      "    while q and i < len(arr):",
      "        curr = q.popleft()",
      "        if arr[i] != -1:",
      "            curr.left = Node(arr[i])",
      "            q.append(curr.left)",
      "        i += 1",
      "        if i < len(arr) and arr[i] != -1:",
      "            curr.right = Node(arr[i])",
      "            q.append(curr.right)",
      "        i += 1",
      "    return root",
      "",
      "n = int(input())",
      "arr = list(map(int, input().split()))",
      "root = buildTree(arr)",
      "",
      "q = deque()",
      "if root: q.append(root)",
      "",
      "while q:",
      "    temp = q.popleft()",
      "    print(temp.data, end=' ')",
      "    if temp.left: q.append(temp.left)",
      "    if temp.right: q.append(temp.right)"
    ],
    "java": [
      "import java.util.*;",
      "",
      "class Node {",
      "    int data;",
      "    Node left, right;",
      "    Node(int d) { data = d; }",
      "}",
      "",
      "public class Main {",
      "    static Node buildTree(int[] arr) {",
      "        if(arr.length == 0 || arr[0] == -1) return null;",
      "        Node root = new Node(arr[0]);",
      "        Queue<Node> q = new LinkedList<>();",
      "        q.add(root);",
      "        int i = 1;",
      "        while(i < arr.length) {",
      "            Node curr = q.poll();",
      "            if(arr[i] != -1) {",
      "                curr.left = new Node(arr[i]);",
      "                q.add(curr.left);",
      "            }",
      "            i++;",
      "            if(i < arr.length && arr[i] != -1) {",
      "                curr.right = new Node(arr[i]);",
      "                q.add(curr.right);",
      "            }",
      "            i++;",
      "        }",
      "        return root;",
      "    }",
      "",
      "    public static void main(String[] args) {",
      "        Scanner sc = new Scanner(System.in);",
      "        int n = sc.nextInt();",
      "        int[] arr = new int[n];",
      "        for(int i=0;i<n;i++) arr[i]=sc.nextInt();",
      "        Node root = buildTree(arr);",
      "",
      "        Queue<Node> q = new LinkedList<>();",
      "        if(root != null) q.add(root);",
      "",
      "        while(!q.isEmpty()) {",
      "            Node curr = q.poll();",
      "            System.out.print(curr.data + \" \");",
      "            if(curr.left != null) q.add(curr.left);",
      "            if(curr.right != null) q.add(curr.right);",
      "        }",
      "    }",
      "}"
    ]
  },
  "solution_explanation": [
    "Queue traversal ensures left-to-right level visits.",
    "Every node is added and processed exactly once -> O(N).",
    "Good for shortest path or broadcasting algorithms in trees."
  ],
  "dummy_test_cases_explanation": [
    {
      "input": "7\n1 2 3 4 5 -1 6",
      "output": "1 2 3 4 5 6",
      "explanation": "Shows left-to-right BFS on each tree level."
    }
  ],
  "tests_industry_standard": [
    {
      "input": "3\n10 20 30",
      "expected_output": "10 20 30",
      "explanation": "Perfect two-level tree"
    },
    {
      "input": "5\n1 2 -1 3 -1",
      "expected_output": "1 2 3",
      "explanation": "Handles missing right nodes gracefully"
    }
  ],
  "dry_run_explanation": [
    "Queue: [1]",
    "Visit 1 → push 2 & 3",
    "Visit 2 → push 4 & 5",
    "Visit 3 → push 6",
    "Visit 4, then 5, then 6"
  ]
},
{
  "id": 903,
  "category_id": 9,
  "question_title": "Height of Binary Tree",
  "question_description": "Given a binary tree, find its height. Input is level order where -1 represents NULL nodes. Height is the number of nodes along the longest path from root to any leaf.",
  "question_level": "Level 2",
  "question_category": "Tree",
  "question_tags": ["tree", "recursion", "height", "dfs"],
  "question_theory": [
    "The height (or depth) of a binary tree is defined as:",
    " - Height of an empty tree = 0",
    " - Height of a leaf node = 1",
    " - Height of a node = 1 + max(height of left subtree, height of right subtree)",
    "DFS recursion is the most direct way to calculate height.",
    "Height represents maximum tree depth and helps in time complexity analysis of tree algorithms."
  ],
  "question_concept": [
    "Read level order input.",
    "Use recursion to compute height:",
    "height(node):",
    " if node is NULL → return 0",
    " return 1 + max(height(left), height(right))"
  ],
  "question_explanation": [
    "The recursive call explores each subtree fully, computing the longest path.",
    "Each node is visited exactly once → O(N).",
    "Height is important for balancing trees and performance of search operations."
  ],
  "solution": {
    "cpp": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "struct Node {",
      "    int data;",
      "    Node* left;",
      "    Node* right;",
      "    Node(int v): data(v), left(NULL), right(NULL) {}",
      "};",
      "",
      "Node* buildTree(vector<int> &arr) {",
      "    if(arr.empty() || arr[0] == -1) return NULL;",
      "    Node* root = new Node(arr[0]);",
      "    queue<Node*> q;",
      "    q.push(root);",
      "    int i = 1;",
      "    while(i < arr.size()) {",
      "        Node* curr = q.front(); q.pop();",
      "        if(arr[i] != -1) { curr->left = new Node(arr[i]); q.push(curr->left); }",
      "        i++;",
      "        if(i < arr.size() && arr[i] != -1) { curr->right = new Node(arr[i]); q.push(curr->right); }",
      "        i++;",
      "    }",
      "    return root;",
      "}",
      "",
      "int height(Node* root) {",
      "    if(!root) return 0;",
      "    return 1 + max(height(root->left), height(root->right));",
      "}",
      "",
      "int main() {",
      "    int n; cin >> n;",
      "    vector<int> arr(n);",
      "    for(int i=0;i<n;i++) cin >> arr[i];",
      "    Node* root = buildTree(arr);",
      "    cout << height(root);",
      "    return 0;",
      "}"
    ],
    "python": [
      "from collections import deque",
      "",
      "class Node:",
      "    def __init__(self, v):",
      "        self.data = v",
      "        self.left = None",
      "        self.right = None",
      "",
      "def buildTree(arr):",
      "    if not arr or arr[0] == -1: return None",
      "    root = Node(arr[0])",
      "    q = deque([root])",
      "    i = 1",
      "    while q and i < len(arr):",
      "        curr = q.popleft()",
      "        if arr[i] != -1:",
      "            curr.left = Node(arr[i])",
      "            q.append(curr.left)",
      "        i += 1",
      "        if i < len(arr) and arr[i] != -1:",
      "            curr.right = Node(arr[i])",
      "            q.append(curr.right)",
      "        i += 1",
      "    return root",
      "",
      "def height(root):",
      "    if not root: return 0",
      "    return 1 + max(height(root.left), height(root.right))",
      "",
      "n = int(input())",
      "arr = list(map(int, input().split()))",
      "root = buildTree(arr)",
      "print(height(root))"
    ],
    "java": [
      "import java.util.*;",
      "",
      "class Node {",
      "    int data;",
      "    Node left, right;",
      "    Node(int d) { data = d; }",
      "}",
      "",
      "public class Main {",
      "    static Node buildTree(int[] arr) {",
      "        if(arr.length == 0 || arr[0] == -1) return null;",
      "        Node root = new Node(arr[0]);",
      "        Queue<Node> q = new LinkedList<>();",
      "        q.add(root);",
      "        int i = 1;",
      "        while(i < arr.length) {",
      "            Node curr = q.poll();",
      "            if(arr[i] != -1) { curr.left = new Node(arr[i]); q.add(curr.left); }",
      "            i++;",
      "            if(i < arr.length && arr[i] != -1) { curr.right = new Node(arr[i]); q.add(curr.right); }",
      "            i++;",
      "        }",
      "        return root;",
      "    }",
      "",
      "    static int height(Node root) {",
      "        if(root == null) return 0;",
      "        return 1 + Math.max(height(root.left), height(root.right));",
      "    }",
      "",
      "    public static void main(String[] args) {",
      "        Scanner sc = new Scanner(System.in);",
      "        int n = sc.nextInt();",
      "        int[] arr = new int[n];",
      "        for(int i=0;i<n;i++) arr[i] = sc.nextInt();",
      "        Node root = buildTree(arr);",
      "        System.out.print(height(root));",
      "    }",
      "}"
    ]
  },
  "solution_explanation": [
    "Recursive DFS to find longest depth.",
    "Every node visited exactly once -> O(N).",
    "Maximum depth returned after subtree comparisons."
  ],
  "dummy_test_cases_explanation": [
    {
      "input": "7\n1 2 3 4 5 -1 6",
      "output": "3",
      "explanation": "Longest path = 1 -> 2 -> 4"
    }
  ],
  "tests_industry_standard": [
    {
      "input": "3\n1 2 3",
      "expected_output": "2",
      "explanation": "Perfect 2-level binary tree"
    },
    {
      "input": "5\n10 20 -1 30 -1",
      "expected_output": "3",
      "explanation": "Skewed left tree"
    }
  ],
  "dry_run_explanation": [
    "arr: 1 2 3 4 5 -1 6",
    "Left subtree height = 3",
    "Right subtree height = 2",
    "Overall height = 1 + max(3,2) = 3"
  ]
},
{
  "id": 904,
  "category_id": 9,
  "question_title": "Count Leaf Nodes",
  "question_description": "Given a binary tree, count the number of leaf nodes. A leaf node is one that has no left and right children. Input is given in level order with -1 representing NULL nodes.",
  "question_level": "Level 1",
  "question_category": "Tree",
  "question_tags": ["tree", "recursion", "leaf"],
  "question_theory": [
    "A leaf node is a terminal node with no children.",
    "In a binary tree, a node is leaf if:",
    " - left child is NULL",
    " - right child is NULL",
    "Leaf nodes represent end points in a tree like decisions in algorithms or values in expression trees."
  ],
  "question_concept": [
    "Recursively visit every node:",
    "If (root->left == NULL && root->right == NULL) return 1",
    "Else return leaf count from left + right subtree",
    "Base case: Empty tree returns 0"
  ],
  "question_explanation": [
    "Every node is checked exactly once → O(N) time complexity.",
    "Recursive structure easily handles partial/missing children."
  ],
  "solution": {
    "cpp": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "struct Node {",
      "    int data;",
      "    Node* left;",
      "    Node* right;",
      "    Node(int v): data(v), left(NULL), right(NULL) {}",
      "};",
      "",
      "Node* buildTree(vector<int> &arr) {",
      "    if(arr.empty() || arr[0] == -1) return NULL;",
      "    Node* root = new Node(arr[0]);",
      "    queue<Node*> q;",
      "    q.push(root);",
      "    int i = 1;",
      "    while(i < arr.size()) {",
      "        Node* curr = q.front(); q.pop();",
      "        if(arr[i] != -1) { curr->left = new Node(arr[i]); q.push(curr->left); }",
      "        i++;",
      "        if(i < arr.size() && arr[i] != -1) { curr->right = new Node(arr[i]); q.push(curr->right); }",
      "        i++;",
      "    }",
      "    return root;",
      "}",
      "",
      "int countLeaves(Node* root) {",
      "    if(!root) return 0;",
      "    if(!root->left && !root->right) return 1;",
      "    return countLeaves(root->left) + countLeaves(root->right);",
      "}",
      "",
      "int main() {",
      "    int n; cin >> n;",
      "    vector<int> arr(n);",
      "    for(int i=0;i<n;i++) cin >> arr[i];",
      "    Node* root = buildTree(arr);",
      "    cout << countLeaves(root);",
      "    return 0;",
      "}"
    ],
    "python": [
      "from collections import deque",
      "",
      "class Node:",
      "    def __init__(self, v):",
      "        self.data = v",
      "        self.left = None",
      "        self.right = None",
      "",
      "def buildTree(arr):",
      "    if not arr or arr[0] == -1: return None",
      "    root = Node(arr[0])",
      "    q = deque([root])",
      "    i = 1",
      "    while q and i < len(arr):",
      "        curr = q.popleft()",
      "        if arr[i] != -1:",
      "            curr.left = Node(arr[i])",
      "            q.append(curr.left)",
      "        i += 1",
      "        if i < len(arr) and arr[i] != -1:",
      "            curr.right = Node(arr[i])",
      "            q.append(curr.right)",
      "        i += 1",
      "    return root",
      "",
      "def countLeaves(root):",
      "    if not root: return 0",
      "    if not root.left and not root.right: return 1",
      "    return countLeaves(root.left) + countLeaves(root.right)",
      "",
      "n = int(input())",
      "arr = list(map(int, input().split()))",
      "root = buildTree(arr)",
      "print(countLeaves(root))"
    ],
    "java": [
      "import java.util.*;",
      "",
      "class Node {",
      "    int data;",
      "    Node left, right;",
      "    Node(int d) { data = d; }",
      "}",
      "",
      "public class Main {",
      "    static Node buildTree(int[] arr) {",
      "        if(arr.length == 0 || arr[0] == -1) return null;",
      "        Node root = new Node(arr[0]);",
      "        Queue<Node> q = new LinkedList<>();",
      "        q.add(root);",
      "        int i = 1;",
      "        while(i < arr.length) {",
      "            Node curr = q.poll();",
      "            if(arr[i] != -1) { curr.left = new Node(arr[i]); q.add(curr.left); }",
      "            i++;",
      "            if(i < arr.length && arr[i] != -1) { curr.right = new Node(arr[i]); q.add(curr.right); }",
      "            i++;",
      "        }",
      "        return root;",
      "    }",
      "",
      "    static int countLeaves(Node root) {",
      "        if(root == null) return 0;",
      "        if(root.left == null && root.right == null) return 1;",
      "        return countLeaves(root.left) + countLeaves(root.right);",
      "    }",
      "",
      "    public static void main(String[] args) {",
      "        Scanner sc = new Scanner(System.in);",
      "        int n = sc.nextInt();",
      "        int[] arr = new int[n];",
      "        for(int i=0;i<n;i++) arr[i] = sc.nextInt();",
      "        Node root = buildTree(arr);",
      "        System.out.print(countLeaves(root));",
      "    }",
      "}"
    ]
  },
  "solution_explanation": [
    "Leaf nodes represent terminal points of recursion.",
    "Combining left and right leaf counts produces final answer.",
    "Traversal cost O(N)."
  ],
  "dummy_test_cases_explanation": [
    {
      "input": "7\n1 2 3 4 5 -1 6",
      "output": "3",
      "explanation": "Leaf nodes are 4, 5, 6"
    }
  ],
  "tests_industry_standard": [
    {
      "input": "3\n1 -1 2",
      "expected_output": "1",
      "explanation": "Skewed right: only node 2 is leaf"
    },
    {
      "input": "1\n5",
      "expected_output": "1",
      "explanation": "A single-node tree is a leaf"
    }
  ],
  "dry_run_explanation": [
    "Tree: 1 → 2,3 → 4,5,6",
    "Leaf check:",
    "4 ✓, 5 ✓, 6 ✓ → total = 3"
  ]
},
{
  "id": 905,
  "category_id": 9,
  "question_title": "Check Balanced Binary Tree",
  "question_description": "Given a binary tree, determine whether it is height-balanced. A tree is balanced if for every node, the absolute difference between heights of left and right subtree is at most 1. Input is level order where -1 represents NULL nodes.",
  "question_level": "Level 3",
  "question_category": "Tree",
  "question_tags": ["tree", "recursion", "height", "balanced"],
  "question_theory": [
    "A binary tree is height-balanced if:",
    "abs(height(left) - height(right)) <= 1 for every node.",
    "Naive approach:",
    " - For each node: calculate height left & right using recursion",
    " - Time: O(N^2)",
    "Optimized approach:",
    " - Compute height and balanced status in the same recursion",
    " - Time: O(N)",
    "Used in AVL Trees, Red-Black Trees balancing, performance checks."
  ],
  "question_concept": [
    "Perform a postorder DFS:",
    " - Check if left subtree balanced",
    " - Check if right subtree balanced",
    " - Compute height = 1 + max(left_height, right_height)",
    " - Node balanced if |lh - rh| <= 1",
    "Return height and balanced result together"
  ],
  "question_explanation": [
    "Postorder traversal ensures heights of both subtrees are already computed.",
    "Early detection of unbalanced subtree avoids extra recursive calls.",
    "Final result: Balanced -> YES, otherwise -> NO"
  ],
  "solution": {
    "cpp": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "struct Node {",
      "    int data;",
      "    Node *left, *right;",
      "    Node(int v) : data(v), left(NULL), right(NULL) {}",
      "};",
      "",
      "Node* buildTree(vector<int>& arr) {",
      "    if(arr.empty() || arr[0] == -1) return NULL;",
      "    Node* root = new Node(arr[0]);",
      "    queue<Node*> q;",
      "    q.push(root);",
      "    int i = 1;",
      "    while(i < arr.size()) {",
      "        Node* curr = q.front(); q.pop();",
      "        if(arr[i] != -1) { curr->left = new Node(arr[i]); q.push(curr->left); }",
      "        i++;",
      "        if(i < arr.size() && arr[i] != -1) { curr->right = new Node(arr[i]); q.push(curr->right); }",
      "        i++;",
      "    }",
      "    return root;",
      "}",
      "",
      "pair<int,bool> check(Node* root) {",
      "    if(!root) return {0,true};",
      "    auto left = check(root->left);",
      "    auto right = check(root->right);",
      "",
      "    int height = 1 + max(left.first, right.first);",
      "    bool balanced = left.second && right.second &&",
      "                    abs(left.first - right.first) <= 1;",
      "",
      "    return {height, balanced};",
      "}",
      "",
      "int main() {",
      "    int n; cin >> n;",
      "    vector<int> arr(n);",
      "    for(int i=0;i<n;i++) cin >> arr[i];",
      "    Node* root = buildTree(arr);",
      "",
      "    cout << (check(root).second ? \"YES\" : \"NO\");",
      "    return 0;",
      "}"
    ],
    "python": [
      "from collections import deque",
      "",
      "class Node:",
      "    def __init__(self, v):",
      "        self.data = v",
      "        self.left = None",
      "        self.right = None",
      "",
      "def buildTree(arr):",
      "    if not arr or arr[0] == -1: return None",
      "    root = Node(arr[0])",
      "    q = deque([root])",
      "    i = 1",
      "    while q and i < len(arr):",
      "        curr = q.popleft()",
      "        if arr[i] != -1:",
      "            curr.left = Node(arr[i])",
      "            q.append(curr.left)",
      "        i += 1",
      "        if i < len(arr) and arr[i] != -1:",
      "            curr.right = Node(arr[i])",
      "            q.append(curr.right)",
      "        i += 1",
      "    return root",
      "",
      "def check(root):",
      "    if not root: return 0, True",
      "    lh, lb = check(root.left)",
      "    rh, rb = check(root.right)",
      "    height = 1 + max(lh, rh)",
      "    balanced = lb and rb and abs(lh - rh) <= 1",
      "    return height, balanced",
      "",
      "n = int(input())",
      "arr = list(map(int, input().split()))",
      "root = buildTree(arr)",
      "print(\"YES\" if check(root)[1] else \"NO\")"
    ],
    "java": [
      "import java.util.*;",
      "",
      "class Node {",
      "    int data;",
      "    Node left, right;",
      "    Node(int d) { data = d; }",
      "}",
      "",
      "public class Main {",
      "    static Node buildTree(int[] arr) {",
      "        if(arr.length == 0 || arr[0] == -1) return null;",
      "        Node root = new Node(arr[0]);",
      "        Queue<Node> q = new LinkedList<>();",
      "        q.add(root);",
      "        int i = 1;",
      "        while(i < arr.length) {",
      "            Node curr = q.poll();",
      "            if(arr[i] != -1) { curr.left = new Node(arr[i]); q.add(curr.left); }",
      "            i++;",
      "            if(i < arr.length && arr[i] != -1) { curr.right = new Node(arr[i]); q.add(curr.right); }",
      "            i++;",
      "        }",
      "        return root;",
      "    }",
      "",
      "    static class Pair {",
      "        int height; boolean balanced;",
      "        Pair(int h, boolean b) { height = h; balanced = b; }",
      "    }",
      "",
      "    static Pair check(Node root) {",
      "        if(root == null) return new Pair(0, true);",
      "        Pair left = check(root.left);",
      "        Pair right = check(root.right);",
      "",
      "        int height = 1 + Math.max(left.height, right.height);",
      "        boolean balanced = left.balanced && right.balanced &&",
      "                           Math.abs(left.height - right.height) <= 1;",
      "",
      "        return new Pair(height, balanced);",
      "    }",
      "",
      "    public static void main(String[] args) {",
      "        Scanner sc = new Scanner(System.in);",
      "        int n = sc.nextInt();",
      "        int[] arr = new int[n];",
      "        for(int i=0;i<n;i++) arr[i] = sc.nextInt();",
      "        Node root = buildTree(arr);",
      "",
      "        System.out.println(check(root).balanced ? \"YES\" : \"NO\");",
      "    }",
      "}"
    ]
  },
  "solution_explanation": [
    "Height and balance checks done in the same pass.",
    "Reduces time complexity from O(N^2) → O(N).",
    "Postorder traversal ensures subtree results ready before decision."
  ],
  "dummy_test_cases_explanation": [
    {
      "input": "7\\n1 2 3 4 5 -1 6",
      "output": "YES",
      "explanation": "Tree heights differ within valid range."
    }
  ],
  "tests_industry_standard": [
    {
      "input": "3\\n1 2 -1",
      "expected_output": "NO",
      "explanation": "Skewed tree height difference = 2 > 1"
    },
    {
      "input": "1\\n10",
      "expected_output": "YES",
      "explanation": "Single node always balanced"
    }
  ],
  "dry_run_explanation": [
    "Tree: 1 → 2,3 → 4,5,6",
    "Left height = 3, Right height = 2",
    "abs(3-2)=1 -> Balanced"
  ]
}





]